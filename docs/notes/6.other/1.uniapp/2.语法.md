# 语法

## pages.json

### pages设置页面

| 属性                         | 说明                     |
| ---------------------------- | ------------------------ |
| navigationBarTitleText       | 头部文本                 |
| navigationBarBackgroundColor | 头部背景色               |
| navigationBarTextStyle       | 头部文本颜色，只有黑与白 |
| enablePullDownRefresh        | 是否开启下拉刷新动画     |

### globalStyle

设置通用的页面样式

### tabBar

设置底部(也可以放顶部)图标切换区域

```json
{
  "pages": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages
    {
      "path": "pages/index/index",
      "style": {
        "navigationBarTitleText": "首页",
        "navigationBarBackgroundColor": "#007AFF",
        "navigationBarTextStyle": "white",
        "enablePullDownRefresh": true
      }
    }
  ],
  "globalStyle": {
    "navigationBarTextStyle": "black",
    "backgroundColor": "#F8F8F8",
    "navigationBarTitleText": "uni-app",
    "navigationBarBackgroundColor": "#F8F8F8",
  },
    "tabBar": {
    "color": "#FFFFFF",
    "selectedColor": "#55ffff",
    "backgroundColor": "#007AFF",
    "list": [{
      "text": "首页",
      "pagePath": "pages/index/index",
      "iconPath": "static/tab/tab_icon3.png",
      "selectedIconPath": "static/tab/tab_icon3_active.png"
    }, {
      "text": "世界",
      "pagePath": "pages/index/index",
      "iconPath": "static/tab/tab_icon2.png",
      "selectedIconPath": "static/tab/tab_icon2_active.png"
    }, {
      "text": "欢迎",
      "pagePath": "pages/index/index",
      "iconPath": "static/tab/tab_icon1.png",
      "selectedIconPath": "static/tab/tab_icon1_active.png"
    }]
  }
}
```

## upx/rpx

upx在2018年推出，其初衷是为了让微信的rpx机制可以跨全端使用，在普通css写法里，upx会被编译器编译。但动态绑定时，upx无法被准确编译，此时官方提出了使用uni.upx2px()方法，用来动态计算

后来其他几家小程序平台陆续都兼容了rpx机制，rpx不再是微信的专用单位，而成为了这个行业的通用单位，最近官方收到很多开发小程序的用户投诉upx不能像rpx那样直接支持动态绑定，还得再使用uni.upx2px方法，官方反思了策略，既然微信不可能支持upx的动态绑定，不如我们在App端和H5端来支持rpx的动态绑定。这样rpx就可以全端通用，且支持动态绑定，不再需要uni.upx2px方法

从HBuilderX 2.0.5起，已经支持rpx的正常着色和px2rpx的ide代码提示转换功能，官方也修改了uni-app文档中关于尺寸单位的介绍，不再推荐upx的使用，而推荐rpx

**这个策略调整，不影响开发者的已有代码正常运行**，开发者仍然可以使用upx和uni.upx2px，也可以改用rpx，都可以。没有必要批量调整老代码。但新开发还是应该使用rpx

顺便提醒另一个事情，很多开发者对响应式单位依赖太严重了，比如组件高度或字体大小也使用upx/rpx，注意只有当你需要某元素的单位要根据屏幕**宽度**（小范围）大小变化时，才需要rpx这类动态宽度单位，一般情况下高度和字体大小是不应该根据屏幕宽度（等比）变化的

## tap/click

在HbuilderX中，两者都是点击时触发事件；不同的是：

1. @click是组件被点击时触发，会有约300ms的延迟（内置处理优化了）
2. @tap是手指触摸离开时触发，没有300ms的延迟，但是会有事件穿透
3. 编译到小程序端，@click会被转换成@tap

## easycom组件

传统vue组件，需要安装、引用、注册，三个步骤后才能使用组件

`easycom`将其精简为一步

只要组件安装在项目的components目录下或`uni_modules`目录下，并符合`components/组件名称/组件名称.vue`目录结构，就可以不用引用、注册，直接在页面中使用

不管components目录下安装了多少组件，`easycom`打包后会自动剔除没有使用的组件，对组件库的使用尤为友好

`easycom`是自动开启的，不需要手动开启

## 条件编译

在`C语言`中，通过 `#ifdef`、`#ifndef` 的方式，可以为 `windows`、`mac` 等不同 os 编译不同的代码。 `uni-app` 参考这个思路，为 `uni-app` 提供了条件编译手段，在一个工程里优雅的完成了平台个性化实现

```vue
<template>
  <view>
    <!-- #ifdef H5 -->
    <view>h5页面显示</view>
    <!-- #endif -->
    <!-- #ifdef MP-WEIXIN -->
    <view>微信小程序页面显示</view>
    <!-- #endif -->
  </view>
</template>

<script>
export default {
  onLoad() {
    // #ifdef H5
    console.log(111)
    // #endif
    // #ifdef MP-WEIXIN
    console.log(222)
    // #endif
  }
}
</script>

<style>
/* #ifdef H5 */
view {
  color: pink;
}
/* #endif */
/* #ifdef MP-WEIXIN */
view {
  color: green;
}
/* #endif */
</style>
```

## webview

嵌套一个线上的html5页面

```js
<template>
  <web-view src="https://zqylzcwcxy.gitee.io/vite-vue-blog/" />
</template>
```

## app端创建或打开文件

```js
    // 请求本地文件系统对象
    plus.io.requestFileSystem(
      plus.io.PUBLIC_DOCUMENTS, // 文件系统中的根目录
      fs => {
        // 创建或打开文件, fs.root是根目录操作对象,直接fs表示当前操作对象
        fs.root.getFile('test.json', {
            create: true // 文件不存在则创建
          }, fileEntry => {
            // 文件在手机中的路径
            console.log(fileEntry.fullPath)
            fileEntry.createWriter(writer => {
              // 写入文件成功完成的回调函数
              writer.onwrite = e => {
                console.log(e, "写入数据成功");
              };
              // 写入数据
              writer.write(JSON.stringify({
                data: ['1', '2']
              }));
            })
          },
          // 获取文件失败
          error => {
            console.log("getFile failed: " + error.message);
          });
      },
      // fs失败
      error => {
        console.log(error.message);
      }
    )
```

## 获取手机系统所有目录文件 

```js
 plus.io.resolveLocalFileSystemURL(
          "file:///storage",
           function(entry) {
                /* 获取文件目录 */
               var directoryReader = entry.createReader(); //获取读取目录对象
                directoryReader.readEntries(
                    function(entries) { //历遍子目录即可
                        for (var i = 0; i < entries.length; i++) {
                            console.log("文件信息：" + entries[i].name);
                         }13                     },
                    function(err) {
                         console.log("访问目录失败");
                    });
             },
             function(err) {
                 console.log("访问指定目录失败:" + err.message);
            });
```

## 删除文件

```js
 delFile() {
      plus.io.requestFileSystem(plus.io.PUBLIC_DOCUMENTS, fs => {
        let rootObj = fs.root
        let fullPath = rootObj.fullPath
        plus.io.resolveLocalFileSystemURL(fullPath + '/allExcels/自动化系统分布情况' + '/' + this.today + '.xlsx', entry => {
          entry.remove(
            () => {
              console.log('删除成功回调')
              //删除成功回调
            },
            err => {
              console.log('删除错误回调', err)
              //删除成功回调
            }
          )
        })
      })
    }
```

