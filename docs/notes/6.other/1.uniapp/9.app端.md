# app端下载图片

## canvas保存图片

1. 绘制canvas
2. 调用uni.canvasToTempFilePath存储临时路径
3. 调用uni.saveImageToPhotosAlbum根据临时路径保存图片至手机相册

```js
<template>
  <view><canvas style="width: 300px; height: 200px;" canvas-id="firstCanvas" id="firstCanvas" @click="exportImg"></canvas></view>
</template>
<script>
export default {
  onReady() {
    var context = uni.createCanvasContext('firstCanvas')
    context.setStrokeStyle('#00ff00')
    context.setLineWidth(5)
    context.rect(0, 0, 200, 200)
    context.stroke()
    context.setStrokeStyle('#ff0000')
    context.setLineWidth(2)
    context.moveTo(160, 100)
    context.arc(100, 100, 60, 0, 2 * Math.PI, true)
    context.moveTo(140, 100)
    context.arc(100, 100, 40, 0, Math.PI, false)
    context.moveTo(85, 80)
    context.arc(80, 80, 5, 0, 2 * Math.PI, true)
    context.moveTo(125, 80)
    context.arc(120, 80, 5, 0, 2 * Math.PI, true)
    context.stroke()
    context.draw()
  },
  methods: {
    exportImg() {
      uni.canvasToTempFilePath({
        fileType: 'jpg',
        canvasId: 'firstCanvas',
        success: function(res) {
          console.log(res.tempFilePath)
          uni.saveImageToPhotosAlbum({
            filePath: res.tempFilePath,
            success: function() {
              uni.showToast({
                icon: 'none',
                position: 'bottom',
                title: '图片已下载至【相册】，请打开【相册】查看'
              })
            }
          })
        }
      })
    }
  }
}
</script>
```

## base64转换图片

1. Bitmap原生图片对象，会占用较大的内存资源，在使用时需谨慎管理，当图片不再使用时应该及时调用clear方法进行销毁
2. loadBase64Data方法加载Base64编码格式图片到Bitmap对象

```js
 const bitmap = new plus.nativeObj.Bitmap('test')
      bitmap.loadBase64Data(
        this.base64,
        function() {
          const url = '_doc/' + new Date().getTime() + '.pdf' // url为时间戳命名方式
          console.log('saveHeadImgFile', url)
          bitmap.save(
            url,
            {
              overwrite: true // 是否覆盖
              // quality: 'quality'  // 图片清晰度
            },
            i => {
              uni.saveImageToPhotosAlbum({
                filePath: url,
                success: function() {
                  uni.showToast({
                    title: '图片保存成功',
                    icon: 'none'
                  })
                  bitmap.clear()
                }
              })
            },
            e => {
              uni.showToast({
                title: '图片保存失败',
                icon: 'none'
              })
              bitmap.clear()
            }
          )
        },
        e => {
          log(e)
          uni.showToast({
            title: '图片保存失败',
            icon: 'none'
          })
          bitmap.clear()
        }
      )
    }
```

## 下载图片至手机相册

提供线上地址

```js
<template>
  <div>
    <img src="https://img-blog.csdnimg.cn/a5afbc54539a4bc79125c6ebf36ba480.png" @click="exportPDF" />
  </div>
</template>

<script>
export default {
  methods: {
    exportPDF() {
      const Url = "https://img-blog.csdnimg.cn/a5afbc54539a4bc79125c6ebf36ba480.png"
      const a = document.createElement("a")
      a.href = Url
      a.download = "download"
      a.click()
    }
  }
}
</script>
```

## 创建或打开文件

```js
    // 请求本地文件系统对象
    plus.io.requestFileSystem(
      plus.io.PUBLIC_DOCUMENTS, // 文件系统中的根目录
      fs => {
        // 创建或打开文件, fs.root是根目录操作对象,直接fs表示当前操作对象
        fs.root.getFile('test.json', {
            create: true // 文件不存在则创建
          }, fileEntry => {
            // 文件在手机中的路径
            console.log(fileEntry.fullPath)
            fileEntry.createWriter(writer => {
              // 写入文件成功完成的回调函数
              writer.onwrite = e => {
                console.log(e, "写入数据成功");
              };
              // 写入数据
              writer.write(JSON.stringify({
                data: ['1', '2']
              }));
            })
          },
          // 获取文件失败
          error => {
            console.log("getFile failed: " + error.message);
          });
      },
      // fs失败
      error => {
        console.log(error.message);
      }
    )
```

## 获取手机系统所有目录文件 

```js
 plus.io.resolveLocalFileSystemURL(
          "file:///storage",
           function(entry) {
                /* 获取文件目录 */
               var directoryReader = entry.createReader(); //获取读取目录对象
                directoryReader.readEntries(
                    function(entries) { //历遍子目录即可
                        for (var i = 0; i < entries.length; i++) {
                            console.log("文件信息：" + entries[i].name);
                         }13                     },
                    function(err) {
                         console.log("访问目录失败");
                    });
             },
             function(err) {
                 console.log("访问指定目录失败:" + err.message);
            });
```

## 删除文件

```js
 delFile() {
      plus.io.requestFileSystem(plus.io.PUBLIC_DOCUMENTS, fs => {
        let rootObj = fs.root
        let fullPath = rootObj.fullPath
        plus.io.resolveLocalFileSystemURL(fullPath + '/allExcels/自动化系统分布情况' + '/' + this.today + '.xlsx', entry => {
          entry.remove(
            () => {
              console.log('删除成功回调')
              //删除成功回调
            },
            err => {
              console.log('删除错误回调', err)
              //删除成功回调
            }
          )
        })
      })
    }
```

