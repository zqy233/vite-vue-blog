# 基础语法

## 类型注解

这是`TypeScript`最基础的语法，为变量提供类型校验，称为**类型注解**，语法为：`变量:类型`

```ts
let isDone: boolean = false
```

## 基础类型

### 原始数据类型

`JavaScript`分为原始数据类型和对象类型，原始数据类型包括：`number`、`string`、`boolean`、`null`、`undefined`和`symbol`。 在`TypeScript`中，相应类型注解为：

```ts
let tsNum: number = 123
let tsStr: string = 'abc'
let tsFlag: boolean = true
let tsNull: null = null
let tsUndefined: undefined = undefined
```

### null与undefined

在`TypeScript`中，`null`和`undefined`是所有类型的子类型，也就是说可以把`undefined`或`null`赋值给原始数据类型的变量

```ts
let tsNumber1: number = undefined
let tsNumber2: number = null
```

### void

`JavaScript`中，是没有空值(`void`)的概念的，但在`TypeScript`中，可以使用`void`来表示一个没有返回值的函数

```ts
function sayHello (): void {
  console.log('Hello, world')
}
```

也可以定义一个`void`类型的变量，不过这样的变量并没有什么意义，因为只能给这种变量赋值为`null`或`undefined`

这也是`void`跟`null`和`undefined`的区别，对于`void`而言，它只能被赋值为`null`或者`undefined`

```ts
let voidValue1: void = null
let voidValue2: void = undefined
// 报错
let voidValue1: void = 123
let voidValue2: void = 'abc'
```

### any

任意值`any`用来表示可以接受任何类型的值

以下代码会报错,因为变量被定义为`number`，那么它只能接受`number`类型的值，不能改变其类型，会编译报错

```ts
let tsNumber: number = 123
tsNumber = '123'
```

但是如果一个变量被定义为`any`，那么代表它可以接受任何类型的值：

```ts
// 以下代码是正确的，编译成功
let tsAny: any = 123
tsAny = '123'
```

如果定义了一个变量，没有指定其类型，也没有初始化，那么它默认为`any`类型

```ts
// 以下代码是正确的，编译成功，因为默认为`any`类型
let tsValue
tsValue = 123
tsValue = '123'
```

## 接口/对象类型

接口`interface`用于为对象提供类型注解, 接口`interface`中的任何代码都不会被最后编译到`JavaScript`中

```ts
interface Person {
  name: string,
  age: number
}
let person: Person = {
  name: 'why',
  age: 23
}
```

在以上代码中，`person`变量它是`Person`类型的，那么此变量只能接受接口规定的属性，且属性值的类型也必须和接口中规定的一致，多一个属性或者少一个属性在`TypeScript`中都不被允许

```ts
interface Person {
  name: string,
  age: number
}
// 编译报错
let person1: Person = {
  name: 'why'
}
// 编译报错
let person2: Person = {
  name: 'why',
  age: 23,
  sex: 'man'
}
```

### 接口中的任意属性

以上一个例子为基础，假设接口只对`name`和`age`做规定，其它任何属性都是可以的，那么可以如下方式进行定义：

```ts
interface Person {
  name: string,
  age: number,
  // 任意属性
  [propName: string]: any
}
let person: Person = {
  name: 'why',
  age: 23,
  sex: 'man'
}
```

### 接口中的可选属性

?:可选属性，代表该属性可存在可不存在，但存在的话类型是有要求的

```ts
interface Person {
  name: string,
  age?: number // age属性是可选的
}
// 编译成功
let person1: Person = {
  name: 'why'
}
let person2: Person = {
  name: 'why',
  age: 23
}
```

### 接口中的只读属性

readonly只读属性，不可修改，在接口中标记了属性为只读的， 那么其不能被赋值。

```ts
interface Person {
  name: string,
  readonly age: number
}
let person: Person = {
  name: 'why',
  age: 23
}
// 编译报错
person.age = 32
```

## 函数类型

为参数和返回值设置类型，不定义相应类型的话，默认为`any`

```ts
function add (x: number, y: number): number {
  return x + y
}
console.log(add(1, 2))    // 输出3
console.log(add(1, '2'))  // 报错
```

也可以使用interface为函数设置类型

```ts
interface AddInterface {
  (x: number, y: number): number
}
/**
 * @param x 数字1
 * @param y 数字2
 * @returns 数字1和数字2之和
 */
const add: AddInterface = (x, y) => {
  return x + y
}
console.log(add(1, 2)) // 输出3
```

### 可选参数

函数接受一个参数，这个参数又是可选的，使用?:

```ts
function getArea (a: number, b?: number): number {
  return  b ? a * b : a * a
}
console.log(getArea(4))     // 16
console.log(getArea(4, 5))  // 20
```

:::warning

可选参数必须放在最后一个位置，否则会报错

:::

```ts
// 编译报错
function getArea (b?: number, a: number): number {
  return  b ? a * b : a * a
}
```

### 参数默认值

在`JavaScript`中，函数允许我们给参数设置默认值，因此另外一种处理可选参数的方式是，为参数提供一个默认值，此时`TypeScript`将会把该参数识别为可选参数：

```ts
function getArea (a: number, b: number = 1): number {
  return  a * b
}
console.log(getArea(4))     // 4
console.log(getArea(4, 5))  // 20
```

:::tip

给一个参数设置了默认值后，就不再受`TypeScript`可选参数必须在最后一个位置的限制了

:::

```ts
function getArea (b: number = 1, a: number): number {
  return  a * b
}
// 传递一个undefined占位,undefined不影响参数1的默认值，仅作占位用
console.log(getArea(undefined,4)) // 4
console.log(getArea(4, 5))        // 20
```

### 剩余参数

在`ES6`中，可以使用`...`符号进行收缩剩余参数，在`TypeScript`中，依然可以这么做

```ts
// rest是一个数组，可以使用数组的类型来定义它
function getTotal (a: number, ...rest: number[]) {
  console.log(a)    // 1
  console.log(rest) // [2, 3, 4]
}

getTotal(1, 2, 3, 4,)
```

### 函数重载

因为在`JavaScript`中，并没有限制函数参数的个数或者类型，因此`JavaScript`没有函数重载的概念，在`TypeScript`中对于函数重载的理解是：只要函数参数的类型或者函数参数的数量不同时，就可以认为这是两个函数(重载)。

```ts
// 前两个为函数声明，最后一个才是函数实现
function add(a: number, b: number): number
function add(a: string, b: string): string
function add(a: boolean, b: boolean): boolean
function add(a: number | string, b: number | string): number | string {
  if (typeof a === "number" && typeof b === "number") {
    return a + b
  } else {
    return a + "" + b
  }
}
console.log(add(1, 2)) // 3
console.log(add("1", "2")) // 12

```

:::tip

在有函数重载时，会优先从第一个进行逐一匹配，因此如果重载函数有包含关系，应该将最精准的函数定义写在最前面

:::

## 数组类型与元组

两种方法定义数组类型

方法一 数组泛型，Array\<type>

```ts
let list: Array<number> = [1, 2, 3]
```

方法二 type[ ] 数组 

```ts
let list: number[] = [1, 2, 3]
```

多种类型的数组称为**元组**

```ts
let nameNumber: [string, number]
```

## 类型推断

在以上的所有实例中，为每一个变量提供了相应的类型，也就是**类型注解**。而有些时候，没有为其提供一个确定的类型，但提供了一个确定的值，那么`TypeScript`会根据给定的值的类型自动推断出这个变量的类型，称为**类型推断**。

```ts
let tsNum = 123 // 类型推断number
let tsStr = 'abc' // 类型推断string
let tsFlag = true // 类型推断boolean
let tsNull = null  // 类型推断any
let tsUndefined = undefined // 类型推断undefined
const helloWorld = {
  hello: 123,
  world:"abc"
}
// 类型推断helloWorld
// const helloWorld = {
// hello: number,
// world: string
// }
```

可见，null和undefined不能推断，并且函数的参数无法推断，必须指定，但返回值可以推断，但建议写上，更加清晰

```ts
function add (num1: number, num2: number): number {
  return num1 + num2
}
// 可以省略函数的返回值类型，因为typescript会基于num1和num1全部为number类型，从而推断出函数返回值为number类型
function add (num1: number, num2: number) {
  return num1 + num2
}
```

## 联合类型 

表示取值可以为多种类型中的一种，多种类型使用`|`分隔开

```ts
let value: string | number
value = 123
value = '123'
```

:::warning

当使用联合类型的时候，因为`TypeScript`不确定到底是哪一个类型，所以`TypeScript`会访问此联合类型的**所有类型公用的属性和方法**

:::

```ts
// length是string独有的属性，所以会报错
function getLength (value: string | number): number {
  return value.length
}

// toString是string和number公用的方法，不会报错
function valueToStr (value: string | number): string {
  return value.toString()
}
```

:::warning

另外一个值得注意的地方就是，当联合类型被赋值后，`TypeScript`会根据类型推断来确定变量的类型，一旦确定后，则此变量只能使用这种类型的属性和方法

:::

```ts
let tsValue: string | number
tsValue = '123'
console.log(tsValue.length) // 编译正确
tsValue = 123
console.log(tsValue.length) // 编译报错
```

## type 类型别名 

```ts
type Add = (x: number, y: number) => number
const add: Add = (a, b) => a + b
add(1,2) // 正确
add('1',2) // 报错，类型“string”的参数不能赋给类型“number”的参数。ts(2345)
```

可以表示接口表示不了的类型, 比如字面量类型(常用来校验取值范围)

```ts
type A = 'top'|'right'|'bottom'|'left' 
let a:A = 'none' // 报错, A类型中没有'none' // 不能将类型“"none"”分配给类型“A”。ts(2322)
```

与其他类型组合

```ts
interface A {
    a: number
}
type B = A | {b: string}
type C = A & {b: string}
const aa: B = {
    a: 1
}
const bb: B = {
    b: "1"
}
const cc: C = {
    a: 1,
    b:'1'
}
// 与泛型组合
type D<T> = A | T[]
```

## interface和type的区别

type和 interface多数情况下有相同的功能，就是定义类型。 但有一些小区别：
type：不是创建新的类型，只是为一个给定的类型起一个名字。type还可以进行联合、交叉等操作，引用起来更简洁interface：创建新的类型，接口之间还可以继承、声明合并。建议优先使用 interface

## ??

与 js中的空值判断运算符一样，是ts中的实现而已。同样是只有运算符左侧的值为null或undefined 时，才会返回右侧的值，否则返回左侧的值。

```ts
const value: string | undefined | null = ''
console.log(value ?? 'value为空值') // 当value为空值时，取默认值
```

## <> 泛型 

根据传入的参数自动判断类型

```ts
function a<T>(arr:T[]):T[] {
    return arr
}
let b = a([1,2,3])
b = [1] // 类型正确
b = ['1'] // ts提示不能将类型“string”分配给类型“number”
```

## as 类型断言 

有些情况下ts系统没办法自动推断出正确的类型, 就需要自行告诉ts这个类型, 断言有2种语法, 一种是通过"<>", 一种通过"as", 举例说明:

```ts
let obj = 0.5 < Math.random() ? 1 : [1] // ts推断类型为number|number[]
obj.push(1) // 报错,类型“number | number[]”上不存在属性“push”。类型“number”上不存在属性“push”。ts(2339)
(obj as number[]).push(1) // 等价下者，告诉ts, obj为数字数组类型
(<number[]>obj).push(1) 
```

## 索引类型keyof

用来获取对象类型的键值

```ts
type A = keyof {a:1,b:'123'} // 'a'|'b'
type B = keyof [1,2] // '1'|'2'|'push'... , 获取到内容的同时, 还得到了Array原型上的方法和属性(实战中暂时没遇到这种需求, 了解即可)
```

## [ : ]

在不确定对象属性名的情况下，形参设置属性名类型

```ts
interface ccache {
    [a:string]:string
}
const cache:ccache = {}
cache.name = 1
console.log(cache)
```

## 内置类型

位于node_modules/typescript/lib/lib.es5.d.ts中

### Readonly 

把每个属性都变成只读

```ts
// 使用
type A  = {a:number, b:string}
type A1 = Readonly<A> // {readonly a: number;readonly b: string;}
// 实现
type Readonly<T> = {
    readonly [P in keyof T]: T[P] // keyof获取T上的键值集合 in表示循环keyof获取的键值
}
```

### Pick

只保留自己选择的属性

```typescript
type A  = {a:number, b:string}
type A1 = Pick<A, 'a'> //  {a:number}
```

### Omit

排除已选的属性

```typescript
type A  = {a:number, b:string}
type A1 = Omit<A, 'a'> // {b:string}
```

### Partial

通过泛型让目标类型中的所有属性变为可选

```typescript
type A  = {a:number, b:string}
type A1 = Partial<A> // { a?: number; b?: string;}
```

### Required

通过泛型让目标类型中的所有属性变为必选

```typescript
type A  = {a?:number, b?:string}
type A1 = Required<A> // { a: number; b: string;}
```

### Record

创建一个类型,k代表键值的类型, T代表值的类型

```typescript
type A1 = Record<string, number>
// 示例一
interface PageInfo {
  title: string;
}
type Page = "home" | "about" | "contact";
const nav: Record<Page, PageInfo> = {
  about: { title: "about" },
  contact: { title: "contact" },
  home: { title: "home" },
};
// 示例二
type keys = 'A' | 'B' | 'C'
const result: Record<keys, number> = {
  A: 1,
  B: 2,
  C: 3
}
```

### ReturnType

获取T的返回值的类型

```js
type A1= ReturnType<()=>number> // number
```

### NonNullable

剔除undefined和null

```js
type A1 = NonNullable<number | string | null | undefined> // number|string
```

### Exclude

 过滤T中和K相同(或兼容)的类型

```typescript
type A  = {a:number, b:string}
type A1 = Exclude<number|string, string|number[]> // number
type A2 = Exclude<number|string, any|number[]> // never , 因为any兼容number, 所以number被过滤掉
```

## extends 

### k  in keyof T

可以简单地理解为取出对象的所有key

```typescript
type required<T> = {
  [p in keyof T]-?: T[p]
}
```

### k extends keyof  T 

可以简单的理解为k是t的子集

```typescript
interface Person {
    age: number;
    name: string;
}
const person: Person = {
    age: 22,
    name: "Tobias",
};
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}
const name1 = getProperty(person, "name");
const gender = getProperty(person, "gender");   //error

```

## declare

1.全局定义类型

2.覆盖默认类型

## typeof

在TypeScript中，typeof操作符可以用来获取一个变量或对象的类型

```typescript
const kakuqo = {
  name: "kakuqo",
  age: 30,
  address: {
    province: "福建",
    city: "厦门"
  }
}
type Kakuqo = typeof kakuqo
```

获取的type如下

```typescript
type Kakuqo = {
    name: string;
    age: number;
    address: {
        province: string;
        city: string;
    };
}
```

## 解构赋值中写类型注解

```typescript
const { dst }： { dst: string } = data.trans_result[0]
const { dst }： any = data.trans_result[0]
```

## is 类型保护

在使用类型保护时，TS 会进一步缩小变量的类型。例子中，将类型从 any 缩小至了 string

```typescript
function isString(test: string): boolean {
  return typeof test === "string"
}
function example(foo: any) {
  if (isString(foo)) {
    // 编译不会出错,运行时出错
    console.log(foo.push(2))
  }
}
example("hello world")
```

```typescript
function isString(test: string): test is string {
  return typeof test === "string"
}
function example(foo: any) {
  if (isString(foo)) {
    // ts直接提示 类型“string”上不存在属性“push”
    console.log(foo.push(2))
  }
}
example("hello world")
```

## unknown

很多情况下, 我们可以使用 unknown 来替代 any , 既灵活, 又可以继续保证类型安全

```typescript
export const isString = (val: unknown): val is string => typeof val === 'string'
```

