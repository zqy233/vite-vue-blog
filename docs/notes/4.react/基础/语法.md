# React

## 1.2.父传子

父直接传

```jsx
import {useState} from 'react'
import Son from './son'
const Father = ()=>{
    const [count,setCount] = useState(0)
    return (
        <div>
            <h1>父组件{count}</h1>
            <button onClick={()=>setCount(count+1)}>点击</button>
            <Son num={count}></Son>
        </div>
    )
}
export default Father
```

子在props中接收

```jsx
const Son = (props)=>{
    return (
        <div>
            <p>{props.num}</p>
        </div>
    )
}
export default Son
```

## 3.子传父

父向子传递回调函数

```jsx
import {useState} from 'react'
import Son from './son'
const Father = ()=>{
    const [count,setCount] = useState(0)
    return (
        <div>
            <h1>父组件{count}</h1>
            <Son num={count} changeCount={(count)=>setCount(count)}></Son>
        </div>
    )
}
export default Father
```

子调用回调函数

```jsx
const Son = (props)=>{
    const {num,changeCount}= props
    return (
        <div>
            <button onClick={()=>changeCount(num+1)}>点击</button>
        </div>
    )
}
export default Son
```

## 4.useCallback

父组件useCallback

```jsx
import {useState,useCallback} from 'react'
import Son from './son'

const Father = ()=>{
    const [count,setCount] = useState(0)
    const changeCount=useCallback(num=>setCount(num),[])
    return (
        <div>
            <h1>父组件{count}</h1>
                <Son num={count} add={changeCount}></Son>
        </div>
    )
}
export default Father
```

子组件useCallback

```jsx
import {useCallback} from 'react'
const Son = (props)=>{
    const {add,num} = props
    const c = useCallback(()=>add(num+1),[num,add])
    return (
        <div>
            <p>{num}</p>
            <button onClick={c}>点击</button>
        </div>
    )
}
export default Son
```

## 5.useContext

祖先中createContex

```jsx
import {useState,createContext} from 'react'
import Son from './son'

export const Context = createContext(0)
const Father = ()=>{
    const [count,setCount] = useState(0)
    return (
        <div>
            <h1>父组件{count}</h1>
            <Context.Provider value={count}>
                <Son add={(num)=>setCount(num)}></Son>
            </Context.Provider>
        </div>
    )
}
export default Father
```

后代useContext

```jsx
import {useContext} from 'react'
import { Context } from "./father"

const Son = (props)=>{
    const count = useContext(Context)
    const {add} = props
    return (
        <div>
            <p>{count}</p>
            <button onClick={()=>add(count+2)}>点击</button>
        </div>
    )
}
export default Son
```

## 6.useMemo

用于减少每次组件重新渲染时重复进行复杂的计算，参数为一个函数和可选的依赖项数组，返回传入函数的调用结果

## 6.react实现v-if

```jsx
{ this.state.istrue && JSX内容 }
```

## 7.react实现v-show

```jsx
<h2 style={{display:data?'block':'none'}}>
```

## 10.antd

### 1.Table组件

```html
 <TabledataSource={this.state.dataSource}                              //数据源columns={columns}                                               //上方菜单栏bordered                                                        //边框线rowKey="id"													    //如果数据源没有默认key属性，为其设置pagination={{ defaultPageSize: 5, showQuickJumper: true }}		//显示分页	/>
```

### 2.Input组件

获取input的输入值e.target.value

```html
<Input placeholder="Write Something" style={{ width: '420px', height: '45px' }} onChange={this.changeInuputValue}></Input>
```

## 11.redux

首先从redux中导入createStore函数

```js
import { createStore } from 'redux'
```

然后定义一个reducer，reducer两个参数，一个是需处理的state数据，另一个是action

```js
const defaultState = {  inputValue: 'write something',  list: [    '早8点开晨会，分配今天的代码任务',    '早9点和项目经理开需求沟通会',    '早10正式开始划水'  ]}//针对不同的传入的action进行不同state数据处理，这就是reducer起的作用const reducer = (state = defaultState, action) => {  console.log('reducer里的state和action', state, action);  // reducer只能接收state，不能改变state  if (action.type === 'changeInput') {    let newState = JSON.parse(JSON.stringify(state))    newState.inputValue = action.value    return newState  }  if (action.type === 'add') {    let newState = JSON.parse(JSON.stringify(state))    newState.list.push(newState.inputValue)    newState.inputValue = ''    return newState  }  if (action.type === 'delete') {    let newState = JSON.parse(JSON.stringify(state))    newState.list.splice(action.index, 1)    console.log(newState);    newState.inputValue = ''    return newState  }  return state}export default reducer
```

最后将reducer传入createStore函数中形成store

```js
const store = createStore(reducer)
```

需要获取store中数据时

```js
store.getState()   //返回一个object对象，包含state的值
```

使用store.subscribe()监听store中数据更新

```js
store.subscribe(() => {     //监听store      this.setState(        //每当store数据变化时就获取store中值赋给页面state        store.getState()      )})
```

需要使用redux的页面中，定义不同的事件进行dispatch   action的操作，从而在reducer中对store中数据进行不同的处理

## 12.React.memo()

React.memo() 用于减少子组件的重新渲染

React.memo 会检查`props`的变更，仅当传入的`props`发生变化时组件才会重新渲染,对复杂对象只会做浅层对比，可以通过传入第二个参数来控制对比过程

第二个参数为一个接收重新渲染前后props的函数

父组件

```jsx
import {useState} from 'react'
import Son from './son'

const Father = ()=>{
    const [count,setCount] = useState(0)
    const a = () => { setCount(count + 1)}
    console.log('父组件渲染了');
    return (
        <div>
            <h1 onClick={a}>父组件{count}</h1>
            <Son></Son>
        </div>
    )
}
export default Father
```

子组件

```jsx
import React from 'react';
const Son = ()=>{
    console.log('子组件被渲染了')
    return (
        <div>
            <p>子组件</p>
        </div>
    )
}
export default React.memo(Son)
```

子组件第二个参数 

```jsx
function MyComponent(props) {
  /* 使用 props 渲染 */
}
function areEqual(prevProps, nextProps) {
  /*
  如果把 nextProps 传入 render 方法的返回结果与
  将 prevProps 传入 render 方法的返回结果一致则返回 true，
  否则返回 false
  */
}
export default React.memo(MyComponent, areEqual);
```

## 13.shouldComponentUpdate

Vue中没有shouldComponentUpdate检查来提高性能的原因

- react: 数据变化之后，用户通过 setState 主动通知框架更新视图
- vue：数据变化之后，框架通过对原生对象和数组类型变更方法的劫持自动发现更新的部分，刷新视图，用户没有手动过程
- react: diff dom，但是不 diff 数据
- vue: diff 数据（其实不能叫 diff，而是通过对更改的劫持，自动获得了 diff），也 diff dom（其实可以不 diff，它这个机制，其实用不到 vdom）



