# React

## 父传子

父直接传

```jsx
import {useState} from 'react'
import Son from './son'
const Father = ()=>{
    const [count,setCount] = useState(0)
    return (
        <div>
            <h1>父组件{count}</h1>
            <button onClick={()=>setCount(count+1)}>点击</button>
            <Son num={count}></Son>
        </div>
    )
}
export default Father
```

子在props中接收

```jsx
const Son = (props)=>{
    return (
        <div>
            <p>{props.num}</p>
        </div>
    )
}
export default Son
```

## 子传父

父向子传递回调函数

```jsx
import {useState} from 'react'
import Son from './son'
const Father = ()=>{
    const [count,setCount] = useState(0)
    return (
        <div>
            <h1>父组件{count}</h1>
            <Son num={count} changeCount={(count)=>setCount(count)}></Son>
        </div>
    )
}
export default Father
```

子调用回调函数

```jsx
const Son = (props)=>{
    const {num,changeCount}= props
    return (
        <div>
            <button onClick={()=>changeCount(num+1)}>点击</button>
        </div>
    )
}
export default Son
```

## useCallback

父组件useCallback

```jsx
import {useState,useCallback} from 'react'
import Son from './son'

const Father = ()=>{
    const [count,setCount] = useState(0)
    const changeCount=useCallback(num=>setCount(num),[])
    return (
        <div>
            <h1>父组件{count}</h1>
                <Son num={count} add={changeCount}></Son>
        </div>
    )
}
export default Father
```

子组件useCallback

```jsx
import {useCallback} from 'react'
const Son = (props)=>{
    const {add,num} = props
    const c = useCallback(()=>add(num+1),[num,add])
    return (
        <div>
            <p>{num}</p>
            <button onClick={c}>点击</button>
        </div>
    )
}
export default Son
```

## useContext

祖先中createContex

```jsx
import {useState,createContext} from 'react'
import Son from './son'

export const Context = createContext(0)
const Father = ()=>{
    const [count,setCount] = useState(0)
    return (
        <div>
            <h1>父组件{count}</h1>
            <Context.Provider value={count}>
                <Son add={(num)=>setCount(num)}></Son>
            </Context.Provider>
        </div>
    )
}
export default Father
```

后代useContext

```jsx
import {useContext} from 'react'
import { Context } from "./father"

const Son = (props)=>{
    const count = useContext(Context)
    const {add} = props
    return (
        <div>
            <p>{count}</p>
            <button onClick={()=>add(count+2)}>点击</button>
        </div>
    )
}
export default Son
```

## useMemo

用于减少每次组件重新渲染时重复进行复杂的计算，参数为一个函数和可选的依赖项数组，返回传入函数的调用结果

## React.memo()

React.memo() 用于减少子组件的重新渲染

React.memo 会检查`props`的变更，仅当传入的`props`发生变化时组件才会重新渲染,对复杂对象只会做浅层对比，可以通过传入第二个参数来控制对比过程

第二个参数为一个接收重新渲染前后props的函数

父组件

```jsx
import {useState} from 'react'
import Son from './son'

const Father = ()=>{
    const [count,setCount] = useState(0)
    const a = () => { setCount(count + 1)}
    console.log('父组件渲染了');
    return (
        <div>
            <h1 onClick={a}>父组件{count}</h1>
            <Son></Son>
        </div>
    )
}
export default Father
```

子组件

```jsx
import React from 'react';
const Son = ()=>{
    console.log('子组件被渲染了')
    return (
        <div>
            <p>子组件</p>
        </div>
    )
}
export default React.memo(Son)
```

子组件第二个参数 

```jsx
function MyComponent(props) {
  /* 使用 props 渲染 */
}
function areEqual(prevProps, nextProps) {
  /*
  如果把 nextProps 传入 render 方法的返回结果与
  将 prevProps 传入 render 方法的返回结果一致则返回 true，
  否则返回 false
  */
}
export default React.memo(MyComponent, areEqual);
```

## shouldComponentUpdate

Vue中没有shouldComponentUpdate检查来提高性能的原因

- react: 数据变化之后，用户通过 setState 主动通知框架更新视图
- vue：数据变化之后，框架通过对原生对象和数组类型变更方法的劫持自动发现更新的部分，刷新视图，用户没有手动过程
- react: diff dom，但是不 diff 数据
- vue: diff 数据（其实不能叫 diff，而是通过对更改的劫持，自动获得了 diff），也 diff dom（其实可以不 diff，它这个机制，其实用不到 vdom）

## react实现v-if

```jsx
{ this.state.istrue && JSX内容 }
```

## react实现v-show

```jsx
<h2 style={{display:data?'block':'none'}}>
```

