# 插件配置

## unplugin-auto-import

自动导入composition api和生成全局typescript声明

### 下载

```sh
yarn add -D unplugin-auto-import
```

### vite.config.ts配置

```ts
import AutoImport from 'unplugin-auto-import/vite'
export default defineConfig({
  plugins: [
    ...
    AutoImport({
      imports: ['vue', 'vue-router'], // 自动导入vue相关函数
      dts: 'src/auto-import.d.ts' // 生成 `auto-import.d.ts` 全局声明
    })
  ]
})
```

## unplugin-vue-components

自动注册和导入组件

### 下载

```sh
yarn add -D unplugin-vue-components
```

### vite.config.ts配置

```ts
import Components from "unplugin-vue-components/vite"
export default defineConfig({
  plugins: [
    ...
     Components({
      dirs: ["src/components"], // 要导入组件的目录路径
      deep: true, // 搜索子目录
      dts: "src/components/components.d.ts", // 生成 `components.d.ts` 全局声明
    })
  ]
})
```

现在src/components目录下的所有vue组件会自动注册为组件，直接使用即可

内置Resolver可以按需导入很多组件库，比如element-plus

```sh
yarn add element-plus
yarn add -D sass  
yarn add -D sass-loader@10.2.0
```

之后如下配置

```ts
import { ElementPlusResolver } from "unplugin-vue-components/resolvers"
export default defineConfig({
  plugins: [
    ...
    Components({
      dirs: ["src/components"], // 要搜索组件的目录的相对路径
      deep: true, // 搜索子目录
      dts: "src/components/components.d.ts", // 生成 `components.d.ts` 全局声明
      resolvers: [
        ElementPlusResolver({
          importStyle: "sass"
        })
      ]
    })
  ]
})
```

这样就可以在页面中直接使用element-plus组件了，是的，不需要在main.ts里导入element-plus，然后进行Vue.use，就是这么厉害，直接在页面中用就完事了，并且按需加载组件和样式，非常的强大

## vite-plugin-pages

vite插件，可以读取文件夹下的vue文件，自动生成vue-router的路由信息，这样以后每次有新的vue页面增加，都不用去更改vue-router的路由信息代码了，减少了工作量

### 下载

```sh
yarn add -D vite-plugin-pages
yarn add vue-router@next
npm i -D vite-plugin-pages
npm i vue-router@next
```

### vite.config.ts配置

```ts
import Pages from "vite-plugin-pages"
export default defineConfig({
  plugins: [
    ...
      Pages({
      // 自动读取src/views下的vue文件，生成路由信息，默认路由路径'/‘
      dirs: [{ dir: "src/views", baseRoute: "/" }],
      // 异步方式加载路由组件
      importMode: "async",
      // 遍历路由信息，给默认路由加一个redirect
      extendRoute(route) {
       if (route.path === "/") return { ...route, redirect: "login" }
      }
    })
  ]
})
```

### main.ts使用vue-router

```typescript
import { createApp } from "vue"
import App from "./App.vue"

import { createRouter, createWebHashHistory } from "vue-router"
// 这里就是vite-plugin-pages生成的路由信息，正常使用即可
import routes from "virtual:generated-pages"

const router = createRouter({
  history: createWebHashHistory(),
  routes
})
createApp(App).use(router).mount("#app")
```

在env.d.ts中加入 /// \<reference types="vite-plugin-pages/client" />来提供typescript支持

```typescript
/// <reference types="vite/client" />
/// <reference types="vite-plugin-pages/client" />
declare module "*.vue" {
  import type { DefineComponent } from "vue"
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types
  const component: DefineComponent<{}, {}, any>
  export default component
}
```

现在可以在src/views下定义vue文件，会自动生成vue-router的路由信息
那么问题来了，遵循的规则是什么呢？很简单，像示例这样即可，我觉得还是很一目了然的，不用太多介绍

- src/views/index.vue -> /
- src/views/index/a.vue -> /a // 这里的a.vue就是index.vue的子路由（children）
- src/views/father.vue -> /father
- src/views/father/son.vue -> /father/son
- src/views/father/[id].vue -> /father/:id
- src/views/[father]/son.vue -> /:father/son

## vite-plugin-md

```sh
yarn add -D vite-plugin-md
```

自动注册 md 文件为 vue 组件

## prism-theme-vars

```sh
yarn add prism-theme-vars
```

prism 主题变量

新建 style.css,在 main.js 中导入

