# 项目配置

## unplugin-auto-import

自动导入composition api和生成全局typescript声明

### 下载

```sh
yarn add -D unplugin-auto-import
```

### vite.config.ts配置

```ts
import AutoImport from 'unplugin-auto-import/vite'
export default defineConfig({
  ...
  plugins: [
    ...
    AutoImport({
      imports: ['vue', 'vue-router', "vuex"], // 自动导入composition api
      dts: 'src/auto-import.d.ts' // 生成 `auto-import.d.ts` 全局声明
    })
  ]
})
```

### vue.config.js配置

```js
const AutoImport = require("unplugin-auto-import/webpack")

module.exports = {
  ...
  configureWebpack: {
    ...
    plugins: [
      AutoImport({
         imports: ["vue", "vue-router", "vuex"], // 自动导入composition api
         dts: "src/auto-import.d.ts", // 生成 `auto-import.d.ts` 全局声明
      })
  }
}
```

### 自定义导入包

unplugin-auto-import内置了一些主流的包，但实际开发中这远远不够

如果想导入其他的包，可以在imports中使用对象形式, 设置自定义按需导入的包，当然，你需要先安装这个包

vite.config.ts设置

```ts
  AutoImport({
         imports: ["vue", "vue-router", { "just-now-time": ["nowTime", "formatTime", "timeCn", "whatDay", "whatDayEn"] }], // 自动导入composition api
         dts: "src/auto-import.d.ts", // 生成 `auto-import.d.ts` 全局声明
      })
```

相当于

```ts
import { nowTime,formatTime,timeCn,whatDay,whatDayEn } from "just-now-time"
```

### 导入本地路径的ts文件

也可以使用自定义导入包的写法，来导入指定路径下的ts文件

src目录下新建test.ts

```ts
export function useA() {
  console.log("A")
}
```

vite.config.ts设置

```ts
 AutoImport({
      imports: ["vue", "@vueuse/core", { "./test": ["useA"] }],
    })
```

相当于

```ts
import { useA } from "./test"
```

## unplugin-vue-components

自动注册和导入组件

### 下载

```sh
yarn add -D unplugin-vue-components
```

#### vite.config.ts配置

```ts
import Components from "unplugin-vue-components/vite"
export default defineConfig({
  plugins: [
    ...
     Components({
      dirs: ["src/components"], // 要导入组件的目录路径
      deep: true, // 搜索子目录
      dts: "src/components/components.d.ts", // 生成 `components.d.ts` 全局声明
    })
  ]
})
```

#### vue.config.js配置

```js
const Components = require("unplugin-vue-components/webpack")

module.exports = {
  ...
  configureWebpack: {
    plugins: [
       ...
      // 自动按需导入element-plus组件
      Components({
        dirs: ["src/components"], // 要导入组件的目录路径
        dts: true, // 搜索子目录
        dts: "src/components/components.d.ts", // 生成 `components.d.ts` 全局声明
      })
    ]
}
```

现在src/components目录下的所有vue组件会自动注册为组件，直接使用即可

### 按需导入组件库

内置Resolver可以按需导入很多组件库，比如element-plus

```sh
yarn add element-plus
yarn add -D sass  
yarn add -D sass-loader@10.2.0
```

之后如下配置

#### vite.config.ts配置

```ts
import Components from "unplugin-vue-components/vite"
import { ElementPlusResolver } from "unplugin-vue-components/resolvers"
export default defineConfig({
  plugins: [
    ...
    Components({
      dirs: ["src/components"], // 要搜索组件的目录的相对路径
      deep: true, // 搜索子目录
      dts: "src/components/components.d.ts", // 生成 `components.d.ts` 全局声明
      resolvers: [
        ElementPlusResolver({
          importStyle: "sass"
        })
      ]
    })
  ]
})
```

#### vue.config.js配置

```js
const Components = require("unplugin-vue-components/webpack")
const { ElementPlusResolver } = require("unplugin-vue-components/resolvers")

module.exports = {
  ...
  configureWebpack: {
    plugins: [
       ...
      // 自动按需导入element-plus组件
      Components({
        dirs: ["src/components"], // 要导入组件的目录路径
        dts: true, // 搜索子目录
        dts: "src/components/components.d.ts", // 生成 `components.d.ts` 全局声明
        resolvers: [
          ElementPlusResolver({
            importStyle: "sass"
          })
        ]
      })
    ]
}
```

这样就可以在页面中直接使用element-plus组件了，是的，不需要在main.ts里导入element-plus，然后进行Vue.use，就是这么厉害，直接在页面中用就完事了，并且按需加载组件和样式，非常的强大

### 全局scss

#### 创建scss文件

新建src/assets/css/global.scss，内容如下：

```js
// 这部分用于更改element-plus主题色
$blue: skyblue;
@forward "element-plus/theme-chalk/src/common/var.scss" with (
  $colors: (
    "primary": (
      "base": $blue
    )
  )
);
:export {
  primaryColor: $blue;
}
// 这部分定义全局的scss混用
@mixin flex {
  display: flex;
  align-items: center;
}

@mixin background {
  background-size: 100% 100%;
  background-repeat: no-repeat;
}
```

#### vite.config.ts配置

```js
export default defineConfig({
  base: "./", // 根路径
  // 全局加载scss文件
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `@use "src/assets/css/element-plus.scss" as *;`,
        charset: false
      }
    }
  },
  ...
})
```

#### vue.config.js配置

```js
module.exports = {
  publicPath: "./", // 根路径
  // 全局加载scss文件
  css: {
    loaderOptions: {
      sass: {
        prependData: `@use "src/assets/css/element-plus.scss" as *;`
      }
    }
  },
  ...
}
```

## vite-plugin-pages

vite插件，可以读取文件夹下的vue文件，自动生成vue-router的路由信息，这样以后每次有新的vue页面增加，都不用去更改vue-router的路由信息代码了，减少了工作量

### 下载

```sh
yarn add -D vite-plugin-pages
yarn add vue-router@next
```

### vite.config.ts配置

```ts
import Pages from "vite-plugin-pages"
export default defineConfig({
  plugins: [
    ...
      Pages({
      // 自动读取src/views下的vue文件，生成路由信息，默认路由路径'/‘
      dirs: [{ dir: "src/views", baseRoute: "/" }],
      // 异步方式加载路由组件
      importMode: "async",
      // 遍历路由信息，给默认路由加一个redirect
      extendRoute(route) {
       if (route.path === "/") return { ...route, redirect: "login" }
      }
    })
  ]
})
```

### main.ts中使用vue-router

```typescript
import { createApp } from "vue"
import App from "./App.vue"

import { createRouter, createWebHashHistory } from "vue-router"
// 这里就是vite-plugin-pages生成的路由信息，正常使用即可
import routes from "virtual:generated-pages"

const router = createRouter({
  history: createWebHashHistory(),
  routes
})
createApp(App).use(router).mount("#app")
```

### 使用typescript支持

在env.d.ts中加入 /// \<reference types="vite-plugin-pages/client" />

```typescript
/// <reference types="vite/client" />
/// <reference types="vite-plugin-pages/client" />
declare module "*.vue" {
  import type { DefineComponent } from "vue"
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types
  const component: DefineComponent<{}, {}, any>
  export default component
}
```

现在可以在src/views下定义vue文件，会自动生成vue-router的路由信息
那么问题来了，遵循的规则是什么呢？很简单，像示例这样即可，我觉得还是很一目了然的，不用太多介绍

- src/views/index.vue -> /
- src/views/index/a.vue -> /a // 这里的a.vue就是index.vue的子路由（children）
- src/views/father.vue -> /father
- src/views/father/son.vue -> /father/son
- src/views/father/[id].vue -> /father/:id
- src/views/[father]/son.vue -> /:father/son

## 综上配置

以上三个插件几乎是vite+vue开发必备

综上的依赖下载

```sh
yarn add -D unplugin-auto-import unplugin-vue-components vite-plugin-pages sass  sass-loader@10.2.0
yarn add element-plus vue-router@next
```

### vite.config.ts配置

```ts
import { defineConfig } from "vite"
import vue from "@vitejs/plugin-vue"
import { resolve } from "path"
import AutoImport from "unplugin-auto-import/vite"
import Components from "unplugin-vue-components/vite"
import { ElementPlusResolver } from "unplugin-vue-components/resolvers"
export default defineConfig({
  base: "./", // 根路径
  // 全局加载的scss文件
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `@use "src/assets/css/element-plus.scss" as *;`,
        charset: false
      }
    }
  },
  plugins: [
    // 识别vue
    vue(),
    // 自动导入vue3中composition api函数
    AutoImport({
      include: [/\.vue$/, /\.vue\?vue/], // 作用于所有vue文件
      dts: "src/auto-import.d.ts", // 生成全局的vue函数的typescript定义
      imports: ["vue", "vue-router", "vuex"] // vue和vue-router都自动导入
    }),
    // 自动按需导入element-plus组件
    Components({
      dts: "src/element-plus-auto-import.d.ts",
      resolvers: [
        ElementPlusResolver({
          importStyle: "sass"
        })
      ]
    })
  ],
  // 路径别名
  resolve: {
    alias: {
      "@": resolve("src"),
      "~@assets": resolve(__dirname, "src/assets"),
      "@utils": resolve("src/utils")
    }
  },
  server: {
    open: true // 是否自动打开浏览器
  }
})

```

### vue.config.js配置

```js
const AutoImport = require("unplugin-auto-import/webpack")
const Components = require("unplugin-vue-components/webpack")
const { ElementPlusResolver } = require("unplugin-vue-components/resolvers")

module.exports = {
  publicPath: "./", // 根路径
  productionSourceMap: false, // 打包后不生成map文件
  // 全局加载的scss文件
  css: {
    loaderOptions: {
      sass: {
        prependData: `@use "src/assets/css/element-plus.scss" as *;`
      }
    }
  },
  configureWebpack: {
    plugins: [
      AutoImport({
        include: [/\.vue$/, /\.vue\?vue/], // 作用于所有vue文件
        dts: "src/auto-import.d.ts", // 生成全局的vue函数的typescript定义
        imports: ["vue", "vue-router", "vuex"] // 自动导入composition api
      }),
      // 自动按需导入element-plus组件
      Components({
        dts: true,
        resolvers: [
          ElementPlusResolver({
            importStyle: "sass"
          })
        ]
      })
    ],
    // 路径别名
    resolve: {
      alias: {
        "@assets": "@/assets",
        "@utils": "@/utils"
      }
    }
  },
  // 端口号
  devServer: {
    port: 8080
  }
}
```

## vite-plugin-md

```sh
yarn add -D vite-plugin-md
```

自动注册 md 文件为 vue 组件

## prism-theme-vars

```sh
yarn add prism-theme-vars
```

prism 主题变量

新建 style.css,在 main.js 中导入

## 安装 vue devtools 

> [vue devtools](https://chrome.zzzmh.cn/info?token=nhdogjmejiglipccpnnnanhbledajbpd) 是一个谷歌插件，用于开发 vue 项目时进行调试

使用[极速插件网(一个快速安装下载谷歌浏览器插件的网站)](https://chrome.zzzmh.cn/info?token=nhdogjmejiglipccpnnnanhbledajbpd)进行下载安装

下载完成后如何安装插件：

1. 打开谷歌浏览器

2. 点击右上角三个点

3. 选择更多工具

4. 选择拓展程序

5. 打开开发者模式

6. 拖拽解压后的插件至浏览器中

## 安装postcss-pxtorem 

用于将px转换成rem

```sh
npm i -D postcss-pxtorem 
```

根目录新建postcss.config.js

```js
module.exports = {
  plugins: {
    autoprefixer: {
      overrideBrowserslist: ["Android 4.1", "iOS 7.1", "Chrome > 31", "ff > 31", "ie >= 8", "last 10 versions"],
      grid: true
    },
    "postcss-pxtorem": {
      rootValue: 160,
      propList: ["*"],
      unitPrecision: 5
    }
  }
}
```

