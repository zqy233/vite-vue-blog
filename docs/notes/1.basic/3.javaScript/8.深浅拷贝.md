## js-深浅拷贝

#### 方法一 JSON.stringify(JSON.parse())

JSON.stringifyJavaScript 对象转换为 JSON 字符串

JSON.parse/ JSON 字符串转换为 JavaScript 对象

eval 转换 JSON 字符串为数组

js 中 object 是引用类型，所以=赋值的方式属于浅拷贝，浅拷贝会复制引用指针，导致浅拷贝后修改拷贝的数组会影响原数组

JSON.stringify(JSON.parse())实现深拷贝，深拷贝不会复制引用指针，修改不会影响原数组

```js
let arr = ['泰迪', '柯基', '金毛']
console.log(typeof arr) //object
const b = JSON.stringify(arr)
console.log(b) // ["泰迪","柯基","金毛"]
console.log(typeof b) //string
```

#### Object.assign

```js
let a = {
  id: '123',
  name: 'zhangsan'
}
let obj = Object.assign({}, a) //obj是深拷贝的对象
obj.id = 123
console.log(obj, a)
```

#### 区别

深拷贝：修改新变量的值不会影响原有变量的值。默认情况下基本数据类型（number，string，null，undefined，boolean）都是深拷贝

浅拷贝：修改新变量的值会影响原有的变量的值。默认情况下引用类型（object）都是浅拷贝

从本质上讲就是浅拷贝只简简单单地把栈当中的引用地址拷贝了一份，所以当你修改新拷贝出来的值的时候，被拷贝的对象也会被你修改掉；而深拷贝是会在堆内存当中为新对象建立空间，所以被拷贝的对象就不会被无缘无故地被修改掉了

#### 解构赋值是浅拷贝还是深拷贝

结论：浅拷贝

#### 代码

```js
function deepClone(source) {
  const targetObj = source.constructor === Array ? [] : {} // 判断复制的目标是数组还是对象
  for (let keys in source) {
    // 遍历目标
    if (source.hasOwnProperty(keys)) {
      if (source[keys] && typeof source[keys] === 'object') {
        // 如果值是对象，就递归一下
        targetObj[keys] = source[keys].constructor === Array ? [] : {}
        targetObj[keys] = deepClone(source[keys])
      } else {
        // 如果不是，就直接赋值
        targetObj[keys] = source[keys]
      }
    }
  }
  return targetObj
}
const obj = {
  a: 1
}
const shallowobj = obj
const deepobj = deepClone(obj)
shallowobj.a = 2 // 浅拷贝
deepobj.a = 3 // 深拷贝
console.log(obj)
console.log(shallowobj)
console.log(deepobj)
```

## 

