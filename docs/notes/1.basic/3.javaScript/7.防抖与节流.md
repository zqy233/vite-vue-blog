# 防抖与节流

> 本质上是优化高频率执行代码的一种手段
>
> 如：浏览器的 `resize`、`scroll`、`keypress`、`mousemove` 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能
>
> 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 **防抖（debounce）** 和 **节流（throttle）** 的方式来减少调用频率

## 防抖

在规定的时间内只触发一次

```js
let debounce = true
if (debounce) {
        debounce = false
        // 此处执行相应方法
        setTimeout(() => {
          debounce = true
        }, 3000)
      }
```

## 节流

在规定的间隔时间内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发

```js
  <script>
      /**
       * 防抖节流
       * @param {*} action 回调
       * @param {*} delay 等待的时间
       * @param {*} context this指针
       * @param {Boolean} iselapsed 是否等待上一次
       * @returns {Function}
       */
      function throttle(action, delay, context, iselapsed) {
        let timeout = null
        let lastRun = 0
        return function () {
          if (timeout) {
            if (iselapsed) {
              return
            } else {
              clearTimeout(timeout)
              timeout = null
            }
          }
          let elapsed = Date.now() - lastRun
          let args = arguments
          if (iselapsed && elapsed >= delay) {
            runCallback()
          } else {
            timeout = setTimeout(runCallback, delay)
          }
          /**
           * 执行回调
           */
          function runCallback() {
            lastRun = Date.now()
            timeout = false
            action.apply(context, args)
          }
        }
      }
    </script>
```

```js
  <script>
      /**
       * 防抖节流
       * @param {*} action 回调
       * @param {*} delay 等待的时间
       * @param {*} context this指针
       * @param {Boolean} iselapsed 是否等待上一次
       * @returns {Function}
       */
      function throttle(action, delay, context, iselapsed) {
        let timeout = null
        let lastRun = 0
        return function () {
          if (timeout) {
            if (iselapsed) {
              return
            } else {
              clearTimeout(timeout)
              timeout = null
            }
          }
          let elapsed = Date.now() - lastRun
          let args = arguments
          if (iselapsed && elapsed >= delay) {
            runCallback()
          } else {
            timeout = setTimeout(runCallback, delay)
          }
          /**
           * 执行回调
           */
          function runCallback() {
            lastRun = Date.now()
            timeout = false
            action.apply(context, args)
          }
        }
      }
    </script>
```

## 只触发最后一次事件

```js
let iTime = ""
  const scollThrottle = () => {
    clearTimeout(iTime)
    iTime = setTimeout(scroll, 100)
  }
```

## 函数只执行一次

方法一，清空函数

```js
let func = function () {
  console.log("正常调用")
  func = function () {}
}
func() //正常调用func();  //空，因为函数被清空了
```

方法二，定义全局boolen变量flag进行判断

```js
let flag = true
function once() {
  if (flag) {
    console.log("正常调用")
    flag = false
  } else {
    return
  }
}
once() //正常调用once();  //空，全局变量flag为空
```
