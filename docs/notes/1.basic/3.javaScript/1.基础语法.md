# 基础语法

## number-Math.round

四舍五入

```js
Math.round(2.3) //2
Math.round(2.6) //3
```

## number-Math.ceil

向上舍入

```js
Math.ceil(2.3) //3
Math.ceil(2.6) //3
```

## number-进制转换

十进制和十六进制

```js
const item = '0x76d0'
console.log(parseInt(item, 16)) // 30416
const num = 30416
console.log(num.toString(16)) // 76d0
```

## Object

JavaScript 中的所有事物都是对象，object，function，array 都属于引用类型 object，即广义上的对象

## Object.values

Object.values 获取对象所有值，合并为数组

```js
const data = { name: 'lhl' }
console.log(Object.values(data)) // ['lhl']
```

## Object.keys

Object.keys 获取对象所有 key，合并为数组

```js
const data = { name: 'lhl' }
console.log(Object.keys(data)) // ['name']
```

## Object.assign

Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象

```js
const target = { a: 1, b: 2 }
const source = { b: 4, c: 5 }
const returnedTarget = Object.assign(target, source)
console.log(target)
console.log(returnedTarget)
```

## Function-函数

函数声明/普通函数

```js
function a(){}
```

函数表达式

```js
const a = function () {}
```

构造函数

```js
function Fn(name) {
    this.name=name
}
let fn = new Fn('constructor function')
```

匿名函数

```js
function(){}
```

对象中的函数

```js
const obj = {
  a: function () {},
  b() {}
}
```

## Function-this指向

| 调用方式                 | this指向                                |
| ------------------------ | --------------------------------------- |
| 函数声明                 | 严格模式下是undefined，正常模式是Window |
| 函数表达式               | 严格模式下是undefined，正常模式是Window |
| 构造函数                 | 实例对象                                |
| 对象中的函数             | 该函数所属的对象                        |
| 事件绑定方法             | 当前事件所绑定的对象                    |
| 定时器函数               | Window                                  |
| 立即执行函数（自调用函数 | 严格模式下是undefined，正常模式是Window |

## Function-箭头函数

- 只有一个参数时可省略括号
- 函数内只有一行代码时可省略{}和 return
- 如果有{}则必须有 return

```js
const b = (a) => {
  //完整形式
  return a
}
const c = (a) => a //简化模式
```

## ES6拼接语法

```js
`数据${data}`
```

## ES6-symbol

symbol 不支持语法："`new Symbol()`"。围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 `new Boolean`、`new String`以及`new Number`，因为遗留原因仍可被创建。所以想创建一个 Symbol 对象，可以通过 object()函数来包装。

直接使用 Symbol()传参后不会转换参数为 symbol 类型而是新建一个 symbol 类型， 使用 [`Symbol.for()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for) 方法和 [`Symbol.keyFor()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/keyFor) 方法从全局的 symbol 注册表设置和取得 symbol。

[`Object.getOwnPropertySymbols()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) 方法让你在查找一个给定对象的符号属性时返回一个 symbol 类型的数组。注意，每个初始化的对象都是没有自己的 symbol 属性的，因此这个数组可能为空，除非你已经在对象上设置了 symbol 属性。

## ES6-BigInt

是一种内置对象，它提供了一种方法来表示大于 `253 - 1` 的整数。这原本是 Javascript 中可以用 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 表示的最大数字。**`BigInt`** 可以表示任意大的整数。

不能用于 [`Math`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math) 对象中的方法；不能和任何 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 `BigInt` 变量在转换成 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 变量时可能会丢失精度。

`BigInt` 和 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 不是严格相等的，但是宽松相等的。 === false == true

## ES6-const/let

先来了解一下 var 的规则，在 function 内部， 加 var 的是局部变量， 不加 var 的则是全局变量，在 function 外部， 不管有没有使用 var 声明变量，都是全局变量

举个栗子：

局部变量

```js
function a() {
  var b = 1
}
a()
console.log(b) // 报错 b is not defined
```

全局变量

```js
function a() {
  b = 1
}
a()
console.log(b) // 1
```

var 的缺陷:

- 希望是局部变量的变量外部却可以访问到
- for 循环指向的都是同一个变量
- 可以重复定义

```js
for (var i = 0; i < 10; i++) {
  var a = 1
}
console.log(i) // 10
console.log(a) // 1
```

```js
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i) //3 3 3
  })
}
```

```js
var a = 1
var a = 2
console.log(a) // 2
```

使用 let 后

```js
for (let i = 0; i < 10; i++) {
  let a = 1
}
console.log(i) // 报错 i is not defined
console.log(a) // 上一步报错，执行不到这一步
```

```js
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i) // 0 1 2
  })
}
```

const 常量 let 变量

优点：

- 声明的变量拥有块级作用域
- 如 for 循环等在每次循环时都创建新的绑定
- 不可以重复定义

声明的全局变量不是全局对象的属性，不存在 window 对象上，而是一个不可见的块作用域中

const 定义原始类型的时候，这个变量是不可以改变的；定义引用类型的时候，指的是当前变量的指针不可以更改，与对象内部的值是否更改无关

## ES6-箭头函数

箭头函数只有一个参数时可以省略（），函数内只有一行代码时可以省略{ } ，同时可以省略 return

注意！有{ } 时，不能省略 return，否则返回空，有 return 时，不能省略 { }，否则直接报错

## ES6-拓展运算符(对象展开符)

展开对象

```js
const obj1 = { name: '周', age: 23 }
const obj2 = {
  ...obj1,
  sex: '男'
}
console.log(obj2) // { name: '周', age: 23, sex: '男' }
```

函数传参

```js
const numbers = [1, 2]
function push(array, ...numbers) {
  array.push(...numbers)
  return array
}
const array = [0]
console.log(push(array, ...numbers)) // [ 0, 1, 2 ]
function add(x, y) {
  return x + y
}
console.log(add(...numbers)) // 3
```

展开数组

```js
console.log(...[1, 2, 3])
// 1 2 3
console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5
```

字符串拆为数组

```js
console.log([...'hello']) // [ "h", "e", "l", "l", "o" ]
```

## ES6-for ... in/for ... of

i 是数组的索引，可以根据索引取值

```js
const a = [{ A: 1 }, { B: 2 }, { C: 3 }]
for (let i in a) console.log(a[i]) //{A:1},{B:2},{C:3}
```

i of 是数据元素

```js
const a = [{ A: 1 }, { B: 2 }, { C: 3 }]
for (let i of a) console.log(i) //{A:1},{B:2},{C:3}
```

## ES6--Promise.all

同时执行接口请求

```js
 async getCode() {
      const res = await Promise.all([getCode("post", { code: "BUSINESS_TYPR" }, "json"), getCode("post", { code: "ROLE_TYPR" }, "json")])
```

## Ajax-简介

全称为 Asynchronous JavaScript And XML，并非编程语言，仅仅组合了浏览器内建的 XMLHttpRequest 对象（从 web 服务器请求数据）和 JavaScript 和 HTML DOM（显示或使用数据），ajax 其实是一个容易误导人的名称。因为目前更流行前后端分离，所以较少使用 XML 来传输数据，更多地使用 JSON 和 formdata，ajax 允许通过与场景后面的 Web 服务器交换数据来异步更新网页。这意味着可以更新网页的部分，而不需要重新加载整个页面

## Ajax-Ajax和XMLHttpRequest的关系

ajax 是一种技术方案，但并不是一种新技术，
ajax 最核心的依赖是浏览器提供的 XMLHttpRequest 对象。
所以用一句话来总结两者的关系：使用 XMLHttpRequest 对象来发送一个 Ajax 请求

## Ajax-fetch

fetch 是一种 HTTP 数据请求的方式，是 XMLHttpRequest 的一种替代方案。fetch 不是 ajax 的进一步封装，而是原生 js。Fetch 函数就是原生 js，没有使用 XMLHttpRequest 对象。

需要先返回一次，第二次才是想要的结果

```js
fetch('http://localhost:3000/test/select', {
  method: 'POST'
})
  .then(function (response) {
    return response
  })
  .then(function (res) {
    if (res.status == 200) {
      console.log(11)
      return
    }
    console.log(222)
  })
```

## js-数据类型

es6 之前五个基本类型一个引用类型，五个基本类型是 null,undefined,string,number,boolean,一个引用类型是 object（包括 object，function，array），

es6 之后新增了 symbol 用来表示独一无二的数，和 bigint，所以总共是八种数据类型

## js-变量提升

什么是变量提升,举个栗子：

```js
function foo() {
  var a = 1
  function a() {}
  console.log(a) //1
}
foo()
```

```js
function foo() {
  var a
  function a() {}
  console.log(a) //a()
}
foo()
```

上方代码 js 是这样解析的

```js
function foo() {
  var a
  function a() {}
  a = 1
  console.log(a) //1
}
foo()
```

```js
function foo() {
  var a
  function a() {}
  console.log(a) //a()
}
foo()
```

变量提升的规则：
变量在声明提升的时候，是全部提升到作用域的最前面
变量赋值时赋值的位置在变量原本定义的位置
所以变量的提升，提升的其实是变量的声明，而不是变量的赋值

```js
function foo() {
  var a = 1
  console.log(a) // 1
  console.log(b) // undefined
  var b = 2
}
foo()
```

解析为：

```js
function foo() {
  var a
  var b
  a = 1
  console.log(a) // 1
  console.log(b) // undefined
  b = 2
}
foo()
```

函数提升则是整个函数整体提升

```js
function foo() {
  console.log(a) //a()
  var a = 1
  console.log(a) //1
  function a() {}
  console.log(a) //1
}
foo()
```

解析为：

```js
function foo() {
  var a
  function a() {}
  console.log(a) // a()
  a = 1
  console.log(a) // 1
  console.log(a) // 1
}
foo()
```

复杂一点的例子

```js
function foo() {
  var a
  var b
  function b() {}
  function a() {}
  console.log(a) // a()
  a = 1
  console.log(a) // 1
  console.log(b) // b()
  b = 2
  console.log(b) //2
}
```

解析为：

```js
function foo() {
  var a
  var b
  function b() {}
  function a() {}
  console.log(a) // a()
  a = 1
  console.log(a) // 1
  console.log(b) // b()
  b = 2
  console.log(b) //2
}
```

隐式全局变量不会提升

```js
function foo() {
  console.log(a)
  console.log(b) // 报错 b is not defined
  b = 'aaa'
  var a = 'bbb'
  console.log(a)
  console.log(b)
}
foo()
```

面试题

```js
console.log(a) //a()
a() //10
var a = 3
function a() {
  console.log(10)
}
console.log(a) //3
a = 6
a() // a is not a function
```

自己调用自己，需要一个结束条件来结束自我调用

原理：每次 return 都会结束函数的运行，但 return 时又调用了函数，从而继续运行下一次函数，又继续 return，又继续调用，直到满足结束条件，没有下一次调用

```js
function sum(n) {
  if (n == 1) return 1
  return sum(n - 1) + n
}
const amount = sum(5)
console.log(amount) //15
```

题目 1：传递两个参数 m，n，返回长度为 m，所有元素都为 n 的数组

```js
function fn(m, n) {
  return m ? fn(m - 1, n).concat(n) : []
}
console.log(fn(5, 4))
;[4, 4, 4, 4, 4]
```

## js-自调用

```js
const add = (function add() {})()
```

## js-闭包

JavaScript 变量可以是局部变量或全局变量（函数内部定义的变量是私有变量，函数外部定义的变量是全局变量）

获取或修改私有变量可以用到内嵌函数

闭包基于内嵌函数，return 一个内嵌函数，在内嵌函数中进行私有变量的处理

函数内部的私有变量可以通过内嵌函数修改

内嵌函数示例：

```
function add()
  {
    let counter = 0;
    function plus()
      {
        counter += 1;
    }
    plus();
    return counter;
}
console.log(add());   //1
```

闭包示例：

```
const add = (function add() {
  let counter = 0;
  return function(){
  return counter +=1}
  })()
  console.log(add()); //1
  console.log(add()); //2
```

## js-||

0 算 false

```js
const a = false || 1
console.log(a) // 1
const b = 0 || 1
console.log(b) // 1
```

```js
const a= 0
if(a){
    console.log(1)
}
```

```js
undefined | '' // 结果为0，interesting
```

## js-return

return 赋值语句的结果是 return 最左侧的变量

```js
let a = 1
const b = 2
function name() {
  return a = b
}
console.log(name())
```

return 有 true 则会 return true

```js
const a = false
const b = true
function name(params) {
  return a || b
}
console.log(name()) //true
```

```js
const a = false
const b = false
function name() {
  return a || b
}
console.log(name()) //false
```

## js-==和===区别

简单来说： == 代表相同， ===代表严格相同

当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比，如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是 false

操作数 1 == 操作数 2， 操作数 1 === 操作数 2

比较过程：

双等号==：

（1）如果两个值类型相同，再进行三个等号(===)的比较

 （2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：

1）如果一个是 null，一个是 undefined，那么相等

2）如果一个是 0，一个是 false，那么相等

3）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较

三等号===:

（1）如果类型不同，就一定不相等

（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是 NaN，那么不相等。（判断一个值是否是 NaN，只能使用 isNaN( ) 来判断）

（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。

（4）如果两个值都是 true，或是 false，那么相等

（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等

（6）如果两个值都是 null，或是 undefined，那么相等

```
const a = 0
console.log(a==false) // true
```

## js-window.onload

window 页面加载完成时调用

```js
window.onload = function () {}
```

## js-localStorage/sessionStorage 

使用 localStorage 创建一个本地存储的 name/value 键值对

localStorage 和 sessionStorage 属性允许在浏览器中存储 key/value 对的数据。

localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除

sessionStorage 只将数据保存在当前会话中，该数据对象临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据

localStorage 本质上是对字符串的读取，有 json 格式时需要 JSON.stringify()转化为字符串。

```js
localStorage.setItem('text', 'hello') //第一种存储方式
localStorage.text = 'world' //第二种存储方式
localStorage.getItem('text') //调用getItem方法取值
localStorage.text //直接取值
localStorage.removeItem('text') //删除localStorage
```

## js-事件冒泡/事件捕获

现有父子孙三层 dom 元素,依次包裹,大小相同,且三层 dom 都有点击事件

```html
<div class="father">
  <div class="son">
    <div class="grandson"></div>
  </div>
</div>
```

事件冒泡执行过程：点击 dom 元素,事件依次向上(向父一级)开始触发,触发顺序为孙>子>父

事件捕获执行过程：点击 dom 元素,事件依次向下(向子一级)开始触发,触发顺序为父>子>孙

## js-addEventListener 和 on 的区别

addEventListenert 第一个参数为事件名，第二个参数为函数，第三个参数为 Boolean,为 true 执行捕获机制,如果是 false 执行冒泡机制,可以省略,默认 false

```js
div.addEventListener('click', () => {
  console.log('click')
})
```

- on 同一个事件只能绑定单个方法,因为绑定多个,后一个会覆盖前一个

- addEventListener 可以给同一个事件绑定多个方法,且方法间不会覆盖,自上而下依次执行

- addEventListener 可以利用第三个参数决定采用事件冒泡还是事件捕获

- addEventListener 它对任何 DOM 元素都是有效的,而不仅仅只对 HTML 元素有效(DOM 不是专为 HTML 设计的，它是通用型的标准，为所有标记语言(如 java 中常见的 xml 等)而设计)

- addEventListener 为 DOM2 级事件绑定，onclick 为 DOM0 级事件绑定()

- 在移除事件上，on 是指针指向 null，例如 document.onclick = null，而 addEventListener 则使用的是独有的移除方法 removeListener（要使用此方法，addEventListener 必须执行的是外部函数或存在函数名，不然则不能使用）

- IE678 只能使用 attachEvent，无 addEventListener

## 鼠标事件

```js
toucshtart // 鼠标点击
touchmove // 鼠标离开
```

## js-dom 事件级别

1. 0 级只能定义一个事件，多事件会互相覆盖。
2. 1 级没有事件
3. 2 级多出了事件的自定义，并且还有事件冒泡和捕获。注意 ie11 以下的写法(IE 事件处理程序没有第三个参数，因为 IE 早期版本只支持事件冒泡，所以默认就是事件冒泡)
4. 3 级多了自定义事件，和一起其他扩展的事件

## js-原型与原型链

对象._proto_ === 其构造函数.prototype

每个对象都有叫做**proto**属性，这个属性会指向该对象的原型。

```js
function Person() {}
const person = new Person()
console.log(person.__proto__ === Person.prototype) // true
```

## js-dom 操作

获取dom

```js
document.querySelector // css选择器，获取单个dom
document.querySelectorAll // css选择器，获取全部dom
```

是否包含类名

```js
element.classList.contains('类名')
```

添加和移除类名

```js
element.classList.add('类名')
element.classList.remove('类名')
```

创建dom

```js
document.createElement('div')
```

## js-for循环

continue和break的区别：

###  continue

   终止本次循环，接着还执行下一次循环

### break

   用于完全结束一个循环，跳出循环体执行循环后面的语句

因为js中for是没有局部作用域的概念的，所以只有把for循环放在函数中时，才可以在for循环中使用return语句
