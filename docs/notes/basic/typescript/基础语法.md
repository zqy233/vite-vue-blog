

## 类型注解

类型注解：变量：类型

```typescript
let isDone: boolean = false
```

## 基础类型

### boolean 布尔值

```typescript
let isDone: boolean = false
```

### number  数字

```typescript
let decLiteral: string|number = 6
```

### string  字符串

```typescript
let name: string = "bob"
```

## Array 数组

### Array\<type> / type[ ] 

两种方法定义数组类型

方法一 数组泛型，Array\<type>

```typescript
let list: Array<number> = [1, 2, 3]
```

方法二 type[ ] 数组 

```typescript
let list: number[] = [1, 2, 3]
```

### 元组

多种类型的数组

```typescript
let nameNumber: [string, number]
```

## interface  接口

用于定义对象的类型

```typescript
interface Num {
    title:string,
    readonly summary:string
}
```

## type 类型别名 

```typescript
type Add = (x: number, y: number) => number
const add: Add = (a, b) => a + b
add(1,2) // 正确
add('1',2) // 报错，类型“string”的参数不能赋给类型“number”的参数。ts(2345)
```

可以表示接口表示不了的类型, 比如字面量类型(常用来校验取值范围)

```typescript
type A = 'top'|'right'|'bottom'|'left' 
let a:A = 'none' // 报错, A类型中没有'none' // 不能将类型“"none"”分配给类型“A”。ts(2322)
```

与其他类型组合

```typescript
interface A {
    a: number
}
type B = A | {b: string}
type C = A & {b: string}
const aa: B = {
    a: 1
}
const bb: B = {
    b: "1"
}
const cc: C = {
    a: 1,
    b:'1'
}
// 与泛型组合
type D<T> = A | T[]
```

## interface和type的区别

type和 interface多数情况下有相同的功能，就是定义类型。 但有一些小区别：
type：不是创建新的类型，只是为一个给定的类型起一个名字。type还可以进行联合、交叉等操作，引用起来更简洁interface：创建新的类型，接口之间还可以继承、声明合并。建议优先使用 interface

## ?:

代表该属性可存在可不存在

```typescript
interface Num {
    title?:string,
    readonly summary:string
}
```

## ??

与 js中的空值判断运算符一样，是ts中的实现而已。同样是只有运算符左侧的值为null或undefined 时，才会返回右侧的值，否则返回左侧的值。

```typescript
const value: string | undefined | null = ''
console.log(value ?? 'value为空值') // 当value为空值时，取默认值
```

## readonly 只读

代表该属性不可修改

```typescript
interface Num {
    title?:string,
    readonly summary:string
}
```

## <> 泛型 

根据传入的参数自动判断类型

```typescript
function a<T>(arr:T[]):T[] {
    return arr
}
let b = a([1,2,3])
b = [1] // 类型正确
b = ['1'] // ts提示不能将类型“string”分配给类型“number”
```

## | 联合类型 

`|` 符号，表示或者，用于多个类型

```typescript
function a<T>(arr:T[]|T):T[]|T {
    return arr
}
let b = a([1,2,3])
b=1 //类型正确
b=[1] //类型正确
b=['1'] //ts提示不能将类型“string”分配给类型“number”
```

## as 类型断言 

有些情况下ts系统没办法自动推断出正确的类型, 就需要自行告诉ts这个类型, 断言有2种语法, 一种是通过"<>", 一种通过"as", 举例说明:

```typescript
let obj = 0.5 < Math.random() ? 1 : [1] // ts推断类型为number|number[]
obj.push(1) // 报错,类型“number | number[]”上不存在属性“push”。类型“number”上不存在属性“push”。ts(2339)
(obj as number[]).push(1) // 等价下者，告诉ts, obj为数字数组类型
(<number[]>obj).push(1) 
```

## 索引类型keyof

用来获取对象类型的键值

```typescript
type A = keyof {a:1,b:'123'} // 'a'|'b'
type B = keyof [1,2] // '1'|'2'|'push'... , 获取到内容的同时, 还得到了Array原型上的方法和属性(实战中暂时没遇到这种需求, 了解即可)
```

## [ : ]

在不确定对象属性名的情况下，形参设置属性名类型

```typescript
interface ccache {
    [a:string]:string
}
const cache:ccache = {}
cache.name = 1
console.log(cache)
```

## 内置类型

位于node_modules/typescript/lib/lib.es5.d.ts中

### Readonly 

把每个属性都变成只读

```typescript
// 使用
type A  = {a:number, b:string}
type A1 = Readonly<A> // {readonly a: number;readonly b: string;}
// 实现
type Readonly<T> = {
    readonly [P in keyof T]: T[P] // keyof获取T上的键值集合 in表示循环keyof获取的键值
}
```

### Pick

只保留自己选择的属性

```typescript
type A  = {a:number, b:string}
type A1 = Pick<A, 'a'> //  {a:number}
```

### Omit

排除已选的属性

```typescript
type A  = {a:number, b:string}
type A1 = Omit<A, 'a'> // {b:string}
```

### Partial

通过泛型让目标类型中的所有属性变为可选

```typescript
type A  = {a:number, b:string}
type A1 = Partial<A> // { a?: number; b?: string;}
```

### Required

通过泛型让目标类型中的所有属性变为必选

```typescript
type A  = {a?:number, b?:string}
type A1 = Required<A> // { a: number; b: string;}
```

### Record

创建一个类型,k代表键值的类型, T代表值的类型

```typescript
type A1 = Record<string, number>
// 示例一
interface PageInfo {
  title: string;
}
type Page = "home" | "about" | "contact";
const nav: Record<Page, PageInfo> = {
  about: { title: "about" },
  contact: { title: "contact" },
  home: { title: "home" },
};
// 示例二
type keys = 'A' | 'B' | 'C'
const result: Record<keys, number> = {
  A: 1,
  B: 2,
  C: 3
}
```

### ReturnType

获取T的返回值的类型

```js
type A1= ReturnType<()=>number> // number
```

### NonNullable

剔除undefined和null

```js
type A1 = NonNullable<number | string | null | undefined> // number|string
```

### Exclude

 过滤T中和K相同(或兼容)的类型

```typescript
type A  = {a:number, b:string}
type A1 = Exclude<number|string, string|number[]> // number
type A2 = Exclude<number|string, any|number[]> // never , 因为any兼容number, 所以number被过滤掉
```

## extends 

### k  in keyof T

可以简单地理解为取出对象的所有key

```typescript
type required<T> = {
  [p in keyof T]-?: T[p]
}
```

### k extends keyof  T 

可以简单的理解为k是t的子集

```typescript
interface Person {
    age: number;
    name: string;
}
const person: Person = {
    age: 22,
    name: "Tobias",
};
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}
const name1 = getProperty(person, "name");
const gender = getProperty(person, "gender");   //error

```

## declare

1.全局定义类型

2.覆盖默认类型

## typeof

在TypeScript中，typeof操作符可以用来获取一个变量或对象的类型

```typescript
const kakuqo = {
  name: "kakuqo",
  age: 30,
  address: {
    province: "福建",
    city: "厦门"
  }
}
type Kakuqo = typeof kakuqo
```

获取的type如下

```typescript
type Kakuqo = {
    name: string;
    age: number;
    address: {
        province: string;
        city: string;
    };
}
```

## 解构赋值中写类型注解

```typescript
const { dst }： { dst: string } = data.trans_result[0]
const { dst }： any = data.trans_result[0]
```

## is 类型保护

在使用类型保护时，TS 会进一步缩小变量的类型。例子中，将类型从 any 缩小至了 string

```typescript
function isString(test: string): boolean {
  return typeof test === "string"
}
function example(foo: any) {
  if (isString(foo)) {
    // 编译不会出错,运行时出错
    console.log(foo.push(2))
  }
}
example("hello world")
```

```typescript
function isString(test: string): test is string {
  return typeof test === "string"
}
function example(foo: any) {
  if (isString(foo)) {
    // ts直接提示 类型“string”上不存在属性“push”
    console.log(foo.push(2))
  }
}
example("hello world")
```

## unknown

很多情况下, 我们可以使用 unknown 来替代 any , 既灵活, 又可以继续保证类型安全

```typescript
export const isString = (val: unknown): val is string => typeof val === 'string'
```

## 定义dom元素

```typescript
const echart = ref<HTMLElement | null>(null)
```

## react类型

函数组件类型

FunctionComponent<P={}>、简写FC<P={}>

一个泛型接口，可以接受一个参数，可以不传,用来定义props的类型

```typescript
interface EditorsProps {
    detail: string
}
//const Editors: React.FunctionComponent<props: EditorsProps> = () => {
const Editors: React.FC<props: EditorsProps> = () => {
    const { detail } = props
    return (<></>)
}
```

