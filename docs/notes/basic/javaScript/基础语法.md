# 基础语法

## Array

### unift

向数组的开头添加一个或更多元素，并返回新的长度。

```js
const arr = ["c", "d"]
console.log(arr.unshift("a", "b")) // 4
console.log(arr); // [ 'a', 'b', 'c', 'd' ]
```

### shift

删除数组第一个元素，不需要参数，shift()会返回当前删除的元素，会修改原数组

```js
const arr = [1,2,3]
console.log(arr.shift())  // 1
console.log(arr)          // [2,3]
```

### pop

删除数组的最后一个元素并返回删除的元素，会修改原数组

```js
const arr = ["1", "2", "3"]
console.log(arr.pop())  // 3
console.log(arr)        // [ '1', '2' ]
```

### map

map() 方法遍历每个数组元素并进行依次处理后，返回一个新数组

所以使用map时需要返回值，并将函数返回值赋给一个新数组

map() 不会改变原数组

参数是一个函数，函数有三个参数，一个必选，两个可选

```js
const arr = [1, 2, 3]
const a = arr.map((a, index, arr) => { return a+1 })
console.log(a)  // [ 2, 3, 4 ] 
const b = arr.map((a, index, arr) => {return index})
console.log(b)  // [0，1，2]
const c = arr.map((a, index, arr) => {return arr})
console.log(a); // [[1, 2, 3],[1, 2, 3],[1, 2, 3]]
```

map遍历并修改数据

```js
const a = [
    { A: 1, B: 2 }, { A: 3, B: 4 }
]
const b = a.map(a => {
    if (a.A == 1) {
        return {
            ...a,
            A: A = 666
        }
    }
    else {
        return a
    }
})
console.log(b) // [ { A: 666, B: 2 }, { A: 3, B: 4 } ]
```

### forEach

遍历每个数组元素，和map一样都不会修改原数组，区别在于没有返回值，返回值是undefined，所以使用forEach不需要返回值

参数是一个函数，函数有三个参数，一个必选，两个可选

用法示例1：修改数组并push到一个新数组

```js
const arr = [1, 2, 3]
const newarr = []//当前的元素 index索引  数组对象本身
arr.forEach((a, index, arr) => {
    a = a + 3;
    newarr.push(a)
    console.log(a)   // 4,5,6  
})
console.log(arr)     // [1,2,3]
console.log(newarr)  // [4,5,6]
```

用法示例2：过滤数组并push到一个新数组

```js
const arr = [1, 2, 3]
let newarr = []
arr.forEach(a => {
    if (a == 2) return  
    newarr.push(a)
})
console.log(newarr) // [ 1, 3 ] 
```

### join

数组转字符串

```js
const arr = ["a", "b", "c", "d"]
const string = arr.join()    // a,b,c,d
console.log(string)
console.log(typeof (arr))    // object
console.log(typeof (string)) // string
```

### concat

concat() 方法用于连接两个或多个数组。

```js
const a = ["a"]; 
const b = ["b","c", "d", "e"];
const f = ["f"]; 
const arr = a.concat(b, f); 
console.log(arr)  // [ 'a', 'b', 'c', 'd', 'e', 'f' ]
```

### fill

fill可以插入数组数据,Array(num)可以产生num大小的数组，Array(num).fill(a)每次生成一个数组元素时都会调用fill方法插入数据

```js
const a = { name: 'A', age: 20, sex: '男' };
const b = Array(1).fill(a)
console.log(b);   // [ { name: 'A', age: 20, sex: '男' } ] 
const c = []
c.push(a)
console.log(c);   // [ { name: 'A', age: 20, sex: '男' } ] 
const d = Array(3).fill(a)
console.log(d);   //[ { name: 'A', age: 20, sex: '男' } ,{ name: 'A', age: 20, sex: '男' } ,{ name: 'A', age: 20, sex: '男' } ] 
```

### filter

遍历数组元素，返回符合条件的数据，为true的保留，为false的滚犊子

示例：返回偶数

```js
const a = [1, 2, 3, 4, 5]
const b = a.filter(item =>
    item % 2 === 0
)
console.log(b);  //[2,4]
```

示例：直接使用true/false的字段来过滤

```js
const a = [{id:1,is:true},{id:2,is:true},{id:3,is:false},{id:4,is:true},{id:5,is:false}]
const b = a.filter(item =>
    item.is
)
console.log(b); //[ { id: 1, is: true }, { id: 2, is: true }, { id: 4, is: true } ] 
```

### include

```js
const foo = 'foo'
const bar = 'bar'
const arr = [foo,bar]
const test = 'foo'
if(arr.includes(test))
console.log('TRUE')
```

## Date

### new Date

不传参的情况下默认返回当前最新世界时时

```js
console.log(new Date()) // Sat Oct 10 2020 10:10:10 GMT+0800 (中国标准时间) 
```

GMT+0800是什么？

0度经线的地方平时，也叫格林平时，英文是Greenwich Mean Time，简称GMT或UT（universal time ），也叫世界时

+0800的意思是，从0度格林经线到北京时区经线（120度东八区时区经线），经差为120度，换算成时间为8小时（120除以15），即北京时间比格林平时快8小时，即new Date()返回的是北京时间即中国标准时间



传参的情况下返回传参字符串的格林平时

字符串要求YYYY-MM-DD 或者 YYYY-MM-DD，可以不传分秒，不传则默认为00:00:00，因为GMT+0800 (GMT+08:00) ，所以最终为08:00:00

```js
const a = new Date('2020-10-10 10:10:10')
console.log(a)  // Sat Oct 10 2020 10:10:10 GMT+0800 (中国标准时间) 
const b = new Date('2020-10-10')
console.log(b) // Sat Oct 10 2020 08:00:00 GMT+0800 (中国标准时间)
```

### data的api

```js
const date = new Date()
date.getFullYear() 
date.getMonth()+1
date.getDate()
date.getHours()
date.getMinutes()
date.getSeconds()
new Date().toISOString().slice(0, 10)
```

### 格式化时间

根据传入的字符串生成YYYY-MM-DD HH:MM:SS时间字符串函数

padStart会根据传入的字符来填充字符串直到相应位数，这里是不到2位就传0，写为padStart(2, ‘0’)

```js
function dealdate(date) {
    const dt = new Date(date)
    const y = dt.getFullYear()
    const m = (dt.getMonth() + 1 + '').padStart(2, '0')
    const d = (dt.getDate() + '').padStart(2, '0')
    const hh = (dt.getHours() + '').padStart(2, '0')
    const mm = (dt.getMinutes() + '').padStart(2, '0')
    const ss = (dt.getSeconds() + '').padStart(2, '0')
    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`
}
```

### toISOString

使用 ISO 标准返回 Date 对象的字符串格式

该标准称为 ISO-8601 ，格式为: YYYY-MM-DDTHH:mm:ss.sssZ

```js
console.log(new Date().toISOString()) // 2021-07-14T06:50:45.306Z 
```

显示当前年月日

```js
new Date().toISOString().slice(0, 10)
```

### 获取毫秒的三种方法

```js
Date.parse(new Date()) // 方法一
new Date().getTime())// 方法二
+new Date() // 方法三,把date的字符串类型转换为数字类型，则会变成毫秒数
```

### Date.parse

解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数，如果该字符串无法识别，或者一些情况下，包含了不合法的日期数值（如：2015-02-31），则返回值为NaN



## Math

### Math.round 

四舍五入

```js
Math.round(2.3) //2
Math.round(2.6) //3
```

### Math.ceil 

向上舍入

```js
Math.ceil(2.3) //3
Math.ceil(2.6) //3
```

### 进制转换

十进制和十六进制

```js
const item = '0x76d0'
console.log(parseInt(item,16))  // 30416
const num = 30416
console.log(num.toString(16))   // 76d0
```



## Object

 JavaScript 中的所有事物都是对象，object，function，array都属于引用类型object，即广义上的对象



###  js数据类型

 es6之前五个基本类型一个引用类型，五个基本类型是null,undefined,string,number,boolean,一个引用类型是object（包括object，function，array），

es6之后新增了symbol用来表示独一无二的数，和bigint，所以总共是八种数据类型



###   symbol

 symbol不支持语法："`new Symbol()`"。围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 `new Boolean`、`new String`以及`new Number`，因为遗留原因仍可被创建。所以想创建一个Symbol对象，可以通过object()函数来包装。

直接使用Symbol()传参后不会转换参数为symbol类型而是新建一个symbol类型， 使用 [`Symbol.for()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for) 方法和  [`Symbol.keyFor()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/keyFor) 方法从全局的symbol注册表设置和取得symbol。

[`Object.getOwnPropertySymbols()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) 方法让你在查找一个给定对象的符号属性时返回一个symbol类型的数组。注意，每个初始化的对象都是没有自己的symbol属性的，因此这个数组可能为空，除非你已经在对象上设置了symbol属性。



### BigInt

是一种内置对象，它提供了一种方法来表示大于 `253 - 1` 的整数。这原本是 Javascript中可以用 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 表示的最大数字。**`BigInt`** 可以表示任意大的整数。

不能用于 [`Math`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math) 对象中的方法；不能和任何 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 `BigInt` 变量在转换成 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 变量时可能会丢失精度。

`BigInt` 和 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 不是严格相等的，但是宽松相等的。  === false == true

### Object.values()与Object.keys()

Object.values获取对象所有值，合并为数组

Object.keys获取对象所有key，合并为数组

```js
const data = { name:'lhl' }
console.log(Object.values(data))  // ['lhl']
const data = { name:'lhl' }
console.log(Object.keys(data))    // ['name']
```

### Object.assign

Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象

```js
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };
const returnedTarget = Object.assign(target, source);
console.log(target);
console.log(returnedTarget);
```

## Function

### 普通函数

函数表达式

```js
const a = function(){}
```

函数声明

```js
const function a(){}
```

匿名函数

```js
function(){}
```

###  对象中的函数

```js
const obj={    
  a:function(){},
  b(){}
}  
```

###  箭头函数

- 语法
- 只有一个参数时可省略括号
- 函数内只有一行代码时可省略{}和return
- 如果有{}则必须有return

```js
const b = (a) => {  //完整形式    
 return a
}
const c = a => a    //简化模式    
```

## String

### ES6拼接语法

```js
`数据${data}`
```

### 数组转字符串，字符串转数组

join    数组转字符串

```js
var fruits = ["Banana", "Orange", "Apple", "Mango"];
var energy = fruits.join();
console.log(energy);
console.log(typeof(fruits)); //object
console.log(typeof(energy)); //string
```

Array.from  字符串转数组

```js
Array.from
```

### 字符串转换数字

- parseInt() 函数解析字符串并返回整数

  ```js
  const a = '111'
  console.log(typeof(parseInt(a))) //number
  ```

- 强制类型转换

  ```js
  const a = "1111" * 1
  console.log(typeof a) // number
  const a = +"1111"
  console.log(typeof a) // number
  ```

### 数字转换字符串

```js
const a= '1111'
console.log(typeof(a.toString()));  //string
```

## ES6

### 1. const/let

先来了解一下var的规则，在function内部， 加var的是局部变量， 不加var的则是全局变量，在function外部， 不管有没有使用var声明变量，都是全局变量

举个栗子：

局部变量

```js
 function a() {
   var b = 1
  }
  a()
  console.log(b) // 报错 b is not defined
```

全局变量

```js
 function a() {
    b = 1
  }
  a()
  console.log(b) // 1
```

var的缺陷:

- 希望是局部变量的变量外部却可以访问到
- for循环指向的都是同一个变量
- 可以重复定义

```js
  for(var i=0;i<10;i++){
          var a = 1
    }
    console.log(i) // 10
    console.log(a) // 1
```

```js
   for (var i = 0; i < 3; i++) {
            setTimeout(function () {
                console.log(i) //3 3 3
            })
        }
```

```js
  var a = 1
  var a = 2
  console.log(a) // 2
```

使用let后

```js
  for(let i=0;i<10;i++){
          let a = 1
    }
    console.log(i) // 报错 i is not defined
    console.log(a) // 上一步报错，执行不到这一步
```

```js
for (let i = 0; i < 3; i++) {
            setTimeout(function () {
                console.log(i) // 0 1 2 
            })
        }
```

const 常量 let变量

优点：

- 声明的变量拥有块级作用域
- 如for循环等在每次循环时都创建新的绑定
- 不可以重复定义

声明的全局变量不是全局对象的属性，不存在window对象上，而是一个不可见的块作用域中

const 定义原始类型的时候，这个变量是不可以改变的；定义引用类型的时候，指的是当前变量的指针不可以更改，与对象内部的值是否更改无关

### 4.1 箭头函数

箭头函数只有一个参数时可以省略（），函数内只有一行代码时可以省略{  } ，同时可以省略return

```
const data = [{code:1,values:'测试1'},{code:2,values:'测试2'},{code:3,values:'测试2'}]console.log(data.filter(a=>  a.code == '1'));//结果为：{code:1,values:'测试1'}
```

所以完整的写法应为

```
const data = [{code:1,values:'测试1'},{code:2,values:'测试2'},{code:3,values:'测试2'}]console.log(data.filter((a)=>{  return a.code == '1'    }));//结果也为：{code:1,values:'测试1'}
```

注意！有{  } 时，不能省略return，否则返回空，有return 时，不能省略 { }，否则直接报错

箭头函数返回对象,使用（）进行对象的包裹

```
const a = (a)=>({type:a})console.log(a(5))  //{type:5}
```

### 4.2 拓展运算符(对象展开符)

展开对象

```js
const obj1 = { name:"周", age: 23 }
const obj2 = { 
 ...obj1,
 sex : "男"
} 
console.log(obj2) // { name: '周', age: 23, sex: '男' }
```

函数传参

```js
const numbers = [1, 2]
function push (array, ...numbers) {
 array.push(...numbers)
  return array
}
const array = [0]
console.log(push(array,...numbers)) // [ 0, 1, 2 ]
function add (x, y) {
 return x + y
}
console.log(add(...numbers)) // 3
```

展开数组

```js
console.log(...[1, 2, 3])
// 1 2 3
console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5
```

字符串拆为数组

```js
console.log([...'hello']) // [ "h", "e", "l", "l", "o" ]
```

### 4.3 FileReader

```js
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width,initial-scale=1, user-scalable=no">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="format-detection" content="telephone=no">
    <title>test</title>
    <script>
        //选择图片时预览功能
        function imageshow(source) {
            var file = source.files[0];
            console.log(file);
            var imageid = source.id;
            if (window.FileReader) {
                var fr = new FileReader();
                fr.onabort = function (e) {
                    console.log('中断了');
                }
                fr.onloadend = function (e) {
                    document.getElementById("portrait" + imageid).src = e.target.result;
                };
                fr.readAsDataURL(file);
            }
            document.getElementById("image" + imageid).style.display = "none";
            document.getElementById("show" + imageid).style.display = "block";
        }
    </script>
</head>

<body>
    <div>
        <div id="image1">
            　　　　　　<p>上传截图</p>
            <input type="file" name="screenshot1" id="1" onchange="imageshow(this)" />
        </div>
        　　　　<div id="show1" style="display:none;">
            　　　　　　<img src="" id="portrait1" width="100" height="70">
            　　　　</div>
        　　　　<div id="image2">
            <p>上传截图</p>
            <input type="file" name="screenshot2" id="2" onchange="imageshow" />
        </div>
        　　　 <div id="show2" style="display:none;">
            　　　　　　<img src="" id="portrait2" width="100" height="70">
            　　　</div>
        <div id="image3">
            <p>上传截图</p>
            <input type="file" name="screenshot3" id="3" onchange="imageshow(this)" />
        </div>
        　　<div id="show3" style="display:none;">
            　　　　　　<img src="" id="portrait3" width="100" height="70">
            　　　　</div>
    </div>
</body>

</html>
```

vue中使用@绑定事件后可以不使用toUpload(this)，因为vue替你传this了，但是需要加上.target

```js
toUpload(event) {
        let self = this
        let reader = new FileReader();
        let img1 = event.target.files[0];
        let type = img1.type; //文件的类型，判断是否是图片
        let size = img1.size; //文件的大小，判断图片的大小
        if (self.imgData.accept.indexOf(type) == -1) {
          self.$toast.top({
            text: '请选择我们支持的图片格式！',
            type: 'warning'
          })
          return false;
        }
        if (size > 512000) {
          self.$toast.top({
            text: '请选择500KB以内的图片！',
            type: 'warning'
          })
          return false;
        }
        let formData = new FormData();
        formData.append('file', img1);
        self.$axios.post(self.$http + '/file/uploadPic', formData, {
            headers: {
              'Content-type': 'multipart/form-data'
            },
          }).then(response => {
            if (response.data.success == true) {
              self.ImgUrl = response.data.data
            }
          })
          .catch(function(error) {
            console.log(error)
          })
      },
```

### 4.4 for ... in/for ... of

i是数组的索引，可以根据索引取值

```js
const a = [{A:1},{B:2},{C:3}]
for(let i in a )
console.log(a[i]); //{A:1},{B:2},{C:3}
```

i of是数据元素

```js
const a = [{A:1},{B:2},{C:3}]
for (let i of a)
console.log(i)  //{A:1},{B:2},{C:3}
```

### 4.5 formdata

```js
const formData = new FormData()
  formData.append('file', img1)
  self.$axios.post(self.$http + '/file/uploadPic', formData, {
    headers: {
     'Content-type': 'multipart/form-data'
    },
   }).then(response => {
    if (response.data.success == true) {
     self.ImgUrl = response.data.data
    }
   })
   .catch(function (error) {
    console.log(error)
   })
```

### promise

promise的then方法内修改全局变量

```js
const f1 =  () => {    return new Promise((resolve, reject) => {    });}; f1().then(()=>{    //在回调里做数据处理 })
```



## Ajax

### 简介

全称为Asynchronous JavaScript And XML，并非编程语言，仅仅组合了浏览器内建的 XMLHttpRequest 对象（从 web 服务器请求数据）和JavaScript 和 HTML DOM（显示或使用数据），ajax其实是一个容易误导人的名称。因为目前更流行前后端分离，所以较少使用 XML 来传输数据，更多地使用 JSON 和formdata，ajax允许通过与场景后面的 Web 服务器交换数据来异步更新网页。这意味着可以更新网页的部分，而不需要重新加载整个页面

### Ajax和XMLHttpRequest的关系

ajax是一种技术方案，但并不是一种新技术，
ajax最核心的依赖是浏览器提供的XMLHttpRequest对象。
所以用一句话来总结两者的关系：使用XMLHttpRequest对象来发送一个Ajax请求



### fetch

fetch是一种HTTP数据请求的方式，是XMLHttpRequest的一种替代方案。fetch不是ajax的进一步封装，而是原生js。Fetch函数就是原生js，没有使用XMLHttpRequest对象。

需要先返回一次，第二次才是想要的结果

```js
 fetch('http://localhost:3000/test/select', {
            method: 'POST',
        }).then(function (response) {
            return response;
        })
            .then(function (res) {
                if (res.status == 200) {
                    console.log(11);
                    return
                }
                console.log(222);
            });
```

### 按顺序执行接口

```js
 async getCode() {
      // 等待翻译接口执行完再执行获取值接口
      const res = await Promise.all([getCode("post", { code: "BUSINESS_TYPR" }, "json"), getCode("post", { code: "ROLE_TYPR" }, "json")])
      if (res[0].status == 200 && res[1].status == 200) {
        this.BUSINESS_TYPR = res[0].data
        this.ROLE_TYPR = res[1].data
        this.getInfoByHistory()
      }
    }
```



## JS特性

### 变量提升

什么是变量提升,举个栗子：

```js
function foo() {
  var a = 1
  function a() {}
  console.log(a) //1
}
foo()
```

```js
function foo() {
  var a
  function a() {}
  console.log(a) //a()
}
foo()
```

上方代码js是这样解析的

```js
function foo() {
  var a
  function a() {}
  a = 1
  console.log(a) //1
}
foo()
```

```js
function foo() {
  var a
  function a() {}
  console.log(a) //a()
}
foo()
```

变量提升的规则：
变量在声明提升的时候，是全部提升到作用域的最前面
变量赋值时赋值的位置在变量原本定义的位置
所以变量的提升，提升的其实是变量的声明，而不是变量的赋值

```js
function foo () {
 var a = 1
 console.log(a) // 1
 console.log(b) // undefined
 var b = 2
}
foo()
```

解析为：

```js
function foo() {
  var a
  var b
  a = 1
  console.log(a); // 1
  console.log(b); // undefined
  b = 2
}
foo()
```

函数提升则是整个函数整体提升

```js
function foo () {
 console.log(a) //a()
 var a = 1
 console.log(a) //1
 function a () {}
 console.log(a) //1
}
foo()
```

解析为：

```js
function foo() {
  var a
  function a() {}
  console.log(a) // a()
  a = 1
  console.log(a) // 1
  console.log(a) // 1
}
foo()
```

复杂一点的例子

```js
function foo(){
 var a
 var b
 function b() {}
 function a() {}
 console.log(a) // a()
 a=1
 console.log(a) // 1
 console.log(b) // b()
 b=2
 console.log(b) //2
}
```

解析为：

```js
function foo(){
 var a
 var b
 function b() {}
 function a() {}
 console.log(a) // a()
 a=1
 console.log(a) // 1
 console.log(b) // b()
 b=2
 console.log(b) //2
}
```

隐式全局变量不会提升

```js
function foo() {
  console.log(a)
  console.log(b) // 报错 b is not defined 
  b = 'aaa'
  var a = 'bbb'
  console.log(a)
  console.log(b)
}
foo()
```

面试题

```js
console.log(a)     //a()
a()                //10
var a = 3
function a() {
  console.log(10)
}
console.log(a)     //3
a = 6
a()                // a is not a function
```

### 深浅拷贝

#### 方法一 JSON.stringify(JSON.parse())

JSON.stringifyJavaScript对象转换为JSON字符串 

JSON.parse/ JSON字符串转换为JavaScript对象

eval 转换JSON字符串为数组

js中object是引用类型，所以=赋值的方式属于浅拷贝，浅拷贝会复制引用指针，导致浅拷贝后修改拷贝的数组会影响原数组

JSON.stringify(JSON.parse())实现深拷贝，深拷贝不会复制引用指针，修改不会影响原数组

```js
let arr = ["泰迪","柯基","金毛"]
console.log(typeof(arr))     //object
const b = JSON.stringify(arr)  
console.log(b)               // ["泰迪","柯基","金毛"] 
console.log(typeof(b))       //string
```

#### Object.assign

```js
  let a = {
        id: "123",
        name: "zhangsan"
      }
      let obj = Object.assign({}, a) //obj是深拷贝的对象
      obj.id = 123
      console.log(obj, a)
```

#### 区别

深拷贝：修改新变量的值不会影响原有变量的值。默认情况下基本数据类型（number，string，null，undefined，boolean）都是深拷贝

浅拷贝：修改新变量的值会影响原有的变量的值。默认情况下引用类型（object）都是浅拷贝

从本质上讲就是浅拷贝只简简单单地把栈当中的引用地址拷贝了一份，所以当你修改新拷贝出来的值的时候，被拷贝的对象也会被你修改掉；而深拷贝是会在堆内存当中为新对象建立空间，所以被拷贝的对象就不会被无缘无故地被修改掉了

#### 解构赋值是浅拷贝还是深拷贝

结论：浅拷贝

#### 代码

```js
 function deepClone(source) {
        const targetObj = source.constructor === Array ? [] : {} // 判断复制的目标是数组还是对象
        for (let keys in source) {
          // 遍历目标
          if (source.hasOwnProperty(keys)) {
            if (source[keys] && typeof source[keys] === "object") {
              // 如果值是对象，就递归一下
              targetObj[keys] = source[keys].constructor === Array ? [] : {}
              targetObj[keys] = deepClone(source[keys])
            } else {
              // 如果不是，就直接赋值
              targetObj[keys] = source[keys]
            }
          }
        }
        return targetObj
      }
      const obj = {
        a: 1
      }
      const shallowobj = obj
      const deepobj = deepClone(obj)
      shallowobj.a = 2 // 浅拷贝
      deepobj.a = 3 // 深拷贝
      console.log(obj)
      console.log(shallowobj)
      console.log(deepobj)
```

### 递归

自己调用自己，需要一个结束条件来结束自我调用

原理：每次return都会结束函数的运行，但return时又调用了函数，从而继续运行下一次函数，又继续return，又继续调用，直到满足结束条件，没有下一次调用

```js
function sum(n){
  if(n==1) return 1;
  return sum(n-1) + n;
}
const amount = sum(5);
console.log(amount);   //15
```

题目1：传递两个参数m，n，返回长度为m，所有元素都为n的数组

```js
function fn(m, n) 
{    return m ? fn(m - 1, n).concat(n) : [];  }  
console.log(fn(5,4)); [ 4, 4, 4, 4, 4 ] 
```

### 自调用

```js
const add = (function add() {})()
```

### 闭包

JavaScript 变量可以是局部变量或全局变量（函数内部定义的变量是私有变量，函数外部定义的变量是全局变量）

获取或修改私有变量可以用到内嵌函数

闭包基于内嵌函数，return一个内嵌函数，在内嵌函数中进行私有变量的处理

函数内部的私有变量可以通过内嵌函数修改     

内嵌函数示例：

```
function add() 
  {  
    let counter = 0;  
    function plus() 
      {
        counter += 1;
    }  
    plus();      
    return counter; 
}
console.log(add());   //1
```

闭包示例：

```
const add = (function add() {
  let counter = 0;  
  return function(){    
  return counter +=1}
  })()
  console.log(add()); //1
  console.log(add()); //2
```

### || 

0算false

```js
const a = false||1
console.log(a) // 1
const b = 0 || 1
console.log(b) // 1
```

```
const a= 0
if(a){
    console.log(1)
}
```

```js
undefined | "" // 结果为0，interesting
```

### return

return 赋值语句的结果是return最左侧的变量

```js
let a = 1
const b = 2
function name() {
    return a = b
}
console.log(name());
```

return有true则会return true

```js
const a = false
const b = true
function name(params) {
    return a || b
}
console.log(name())  //true
```

```js
const a = false
const b = false
function name() {
    return a || b
}
console.log(name())  //false
```

### ==和===区别

简单来说： == 代表相同， ===代表严格相同   

当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比，如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false

操作数1 == 操作数2， 操作数1 === 操作数2

比较过程：

　　双等号==： 

　　（1）如果两个值类型相同，再进行三个等号(===)的比较
　　

​       （2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：

　　　　1）如果一个是null，一个是undefined，那么相等

　           2）如果一个是0，一个是false，那么相等

　　　　3）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较

　　三等号===:

　　（1）如果类型不同，就一定不相等

　　（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）

　　（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。

　　（4）如果两个值都是true，或是false，那么相等

　　（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等

　　（6）如果两个值都是null，或是undefined，那么相等

```
const a = 0
console.log(a==false) // true
```

### apply call bind 异同

相同

1.都是用来重定义 this指向

2.第一个参数都是 this 的指向对象

不同

1,bind返回的是一个新的函数

2.参数不同

## window对象

### onload 

window页面加载完成时调用

```js
window.onload = function () {}
```

### localStorage

使用 localStorage 创建一个本地存储的 name/value 键值对

localStorage 和 sessionStorage 属性允许在浏览器中存储 key/value 对的数据。

localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除

sessionStorage只将数据保存在当前会话中，该数据对象临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据

localStorage本质上是对字符串的读取，有json格式时需要JSON.stringify()转化为字符串。

```js
localStorage.setItem("text", "hello")      //第一种存储方式
localStorage.text ="world"                 //第二种存储方式
localStorage.getItem("text")               //调用getItem方法取值
localStorage.text   		              //直接取值
localStorage.removeItem("text")  	       //删除localStorage	
```

## dom操作

### 获取dom

```js
  document.querySelector // css选择器，获取单个dom
  document.querySelectorAll // css选择器，获取全部dom
```

### dom是否包含类名

```js
获取的dom.classList.contains('类名')
```

### 移除和添加dom类名

```js
获取的dom.classList.add("类名")
获取的dom.classList.remove("类名")
```

### 创建和删除dom

```js
document.createElement('div')
document.createElement("span")
```

### e.target不会冒泡

```js
 <div class="imgBox" onclick="big(event)">
        <img src="">
</div>
function big(e) {
        const img = e.target  // a是图片，e.target不会冒泡
}
```

### element.getBoundingClientRect()/offsetTop

element.getBoundingClientRect().top 是元素相对于页面可视顶部

offsetParent：该属性返回一个对象的引用，这个对象是距离调用offsetParent的元素最近的（在包含层次中最靠近的），已进行过CSS定位的容器元素。 如果这个容器元素未进行CSS定位, 则offsetParent属性的取值为body元素的引用。 当容器元素的style.display 被设置为 "none"时（译注：IE和Opera除外），offsetParent属性 返回 null

clientTop：元素上边框的厚度，当没有指定边框厚底时，一般为0

scrollTop：位于对象最顶端和窗口中可见内容的最顶端之间的距离，简单地说就是滚动后被隐藏的高度。

offsetTop：获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)距离顶端的高度。

clientHeight：内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个工具条以下到状态栏以上的这个区域，与页面内容无关。

scrollHeight：IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。

offsetHeight：获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)的高度。IE、Opera 认为 offsetHeight = clientHeight + 滚动条 + 边框。FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。offsetHeight在新版本的FF和IE中是一样的，表示网页的高度，与滚动条无关，chrome中不包括滚动条。



### document.documentElement

document.documentElement.scrollHeight  总高度，距离顶部的滚动距离+可视范围的高度

document.documentElement.scrollTop   距离顶部的滚动距离

document.documentElement.clientHeight  可视范围的高度



### 获取event

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <button onclick="a(event)">点击</button>
    <input onkeypress="a(event)" />
    <script>
      function a(e) {
        console.log(111)
        console.log(e)
      }
    </script>
  </body>
</html>
```

## 正则表达式

###  基础规则

```bash
. 表示除换行符以外的所有字符。
^ 表示开始 严格匹配按规定的正则开始 否则返回false
// 示例，正则/\d/,匹配字符串为a123,从第一个字符依次匹配,发现存在数字1,符合正则，返回true;加上^后,正则为/^\d/,发现第一个字符是a，直接返回false
$ 表示结束 严格匹配按规定的正则结束 否则返回false
// 示例，正则/\d/,匹配字符串为123a,从第一个字符依次匹配,发现存在数字1,符合正则，返回true;加上$后,正则为/\d$/,发现末尾是a，返回false
\d,\w,\s 分别匹配数字、字符、空格。
\D,\W,\S 分别匹配非数字、非字符、非空格。
[abc]  匹配 a、b 或 c 中的一个字母。
[a-z]  匹配 a 到 z 中的一个字母。
[^abc] 匹配除了 a、b 或 c 中的其他字母。
aa|bb  匹配 aa 或 bb。
?   0 次或 1 次匹配。
*   匹配 0 次或多次。
+   匹配 1 次或多次。
{n} 匹配 n次。
{n,} 匹配 n次以上。
{m,n} 最少 m 次，最多 n 次匹配。
(expr) 捕获 expr 子模式,以 \1 使用它。
(?:expr) 忽略捕获的子模式。
(?=expr) 正向预查模式 expr。
(?!expr) 负向预查模式 expr。
```

### 判断特殊字符

```js
txt.replace(/[.,;':]/g,"")
```

```js
const regexp= RegExp(/[(\ )(\~)(\!)(\@)(\#)(\$)(\%)(\^)(\&)(\*)()()()(\-)(\_)(\+)(\=)()()()(\{)(\})(\|)(\\)(\;)(\:)(\')(\")(\,)(\.)(\/)(\<)(\>)(\?)(\)]+/)
```

## 事件

### 事件冒泡/事件捕获

现有父子孙三层dom元素,依次包裹,大小相同,且三层dom都有点击事件

```html
<div class="father">
   <div class="son">
      <div class="grandson"></div>
   </div>
</div>
```

事件冒泡执行过程：点击dom元素,事件依次向上(向父一级)开始触发,触发顺序为孙>子>父

事件捕获执行过程：点击dom元素,事件依次向下(向子一级)开始触发,触发顺序为父>子>孙

### addEventListener和on的区别

addEventListenert第一个参数为事件名，第二个参数为函数，第三个参数为Boolean,为true执行捕获机制,如果是false执行冒泡机制,可以省略,默认false

```js
div.addEventListener("click", ()=>{
  console.log('click')
})
```

- on同一个事件只能绑定单个方法,因为绑定多个,后一个会覆盖前一个

- addEventListener可以给同一个事件绑定多个方法,且方法间不会覆盖,自上而下依次执行

- addEventListener可以利用第三个参数决定采用事件冒泡还是事件捕获

- addEventListener它对任何DOM元素都是有效的,而不仅仅只对HTML元素有效(DOM不是专为HTML设计的，它是通用型的标准，为所有标记语言(如java中常见的xml等)而设计)

- addEventListener为DOM2级事件绑定，onclick为DOM0级事件绑定()

- 在移除事件上，on是指针指向null，例如document.onclick = null，而addEventListener则使用的是独有的移除方法removeListener（要使用此方法，addEventListener必须执行的是外部函数或存在函数名，不然则不能使用）

- IE678只能使用attachEvent，无addEventListener


###  鼠标事件

```js
touchstart // 鼠标点击
touchmove // 鼠标离开
```

### dom事件级别

1. 0级只能定义一个事件，多事件会互相覆盖。
2. 1级没有事件
3. 2级多出了事件的自定义，并且还有事件冒泡和捕获。注意ie11以下的写法(IE事件处理程序没有第三个参数，因为IE早期版本只支持事件冒泡，所以默认就是事件冒泡)
4. 3级多了自定义事件，和一起其他扩展的事件

### 原型与原型链

对象._proto_ === 其构造函数.prototype

每个对象都有叫做__proto__属性，这个属性会指向该对象的原型。

```js
function Person() {}
const person = new Person()
console.log(person.__proto__ === Person.prototype) // true
```
