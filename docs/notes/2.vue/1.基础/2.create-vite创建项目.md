# create-vite 创建项目

## 安装

```sh
# npm
npm init vite
# yarn
yarn create vite
```

这跟@vue-cli 有了明显区别，不需要安装全局的脚手架命令

原理在于：npm init \<initializer>命令将使用 npx 安装名为 create-\<initializer> 的 npm 包，将，然后执行其 package.json 中 bin 属性对应的脚本，所以该命令实际上是使用 npx 运行 [create-vite](https://www.npmjs.com/package/create-vite) 这个 npm 包，从而下载vite项目模板

npm init 命令相对应的一些示例：

| 命令              | 等同                |
| ----------------- | ------------------- |
| npm init foo      | npx create-foo      |
| npm init @usr     | npx @usr/create     |
| npm init @usr/foo | npx @usr/create-foo |

> 另外，取自 [create-vite](https://www.npmjs.com/package/create-vite) 官方文档：

> 兼容性说明: Vite 要求 Node.js 版本 >=12.2.0，一些模板的正常使用还需要更高的 Node.js 版本, 所以如果您在 node 使用过程中产生了相应警告，请升级

直接创建模板

```sh
# npm 6.x
npm create vite vue-project-name --template vue
# npm 7+, extra double-dash is needed:
npm create vite vue-project-name -- --template vue
# yarn
yarn create vite vue-project-name --template vue
# pnpm
pnpm create vite vue-project-name -- --template vue
```

创建支持typescript的模板

```sh
# npm 6.x
npm create vite vue-project-name --template vue-ts
# npm 7+, extra double-dash is needed:
npm create vite vue-project-name -- --template vue-ts
# yarn
yarn create vite vue-project-name --template vue-ts
# pnpm
pnpm create vite vue-project-name -- --template vue-ts
```

跟 vue-cli 不同的，需要进入目录后自行下载依赖

```sh
# 进入项目目录
cd vue-project-name
# 使用vscode打开项目
code ./
# yarn
yarn
# 运行项目
npm run dev
```

## vite 中图片路径

### 1.使用绝对路径或相对路径

```html
<img src="src/assets/img"/>
```

```html
<img src="../../assets/img"/>
```

### 2.动态绑定路径

因为vite中没有require，动态绑定路径可以使用vite特定的文件系统，main.ts中定义相应全局函数

```ts
<template><img :src="requireImg('logo.png')" /></template>

<script lang="ts" setup>
const requireImg = (name: string) => {
  const path = `/src/assets/${name}`
  const modules = import.meta.globEager("/src/assets/*")
  return modules[path].default
}
</script>
```

## unplugin-auto-import

vite插件，自动导入composition api和生成全局typescript说明

### 下载

```sh
yarn add -D unplugin-auto-import
```

### vite.config.ts配置

```ts
import AutoImport from 'unplugin-auto-import/vite'
export default defineConfig({
  plugins: [
    ...
    AutoImport({
      imports: ['vue', 'vue-router'], // 自动导入vue相关函数
      dts: 'src/auto-import.d.ts' // 生成 `auto-import.d.ts` 全局声明
    })
  ]
})
```

## unplugin-vue-components

vite插件，自动注册和导入组件

### 下载

```sh
yarn add -D unplugin-vue-components
```

### vite.config.ts配置

```ts
import Components from "unplugin-vue-components/vite"
export default defineConfig({
  plugins: [
    ...
     Components({
      dirs: ["src/components"], // 要导入组件的目录路径
      deep: true, // 搜索子目录
      dts: "src/components/components.d.ts", // 生成 `components.d.ts` 全局声明
    })
  ]
})
```

现在src/components目录下的所有vue组件会自动注册为组件，直接使用即可

内置Resolver可以按需导入很多组件库，比如element-plus

```sh
yarn add element-plus
yarn add -D sass  
yarn add -D sass-loader@10.2.0
```

之后如下配置

```ts
import { ElementPlusResolver } from "unplugin-vue-components/resolvers"
export default defineConfig({
  plugins: [
    ...
    Components({
      dirs: ["src/components"], // 要搜索组件的目录的相对路径
      deep: true, // 搜索子目录
      dts: "src/components/components.d.ts", // 生成 `components.d.ts` 全局声明
      resolvers: [
        ElementPlusResolver({
          importStyle: "sass"
        })
      ]
    })
  ]
})
```

这样就可以在页面中直接使用element-plus组件了，是的，不需要在main.ts里导入element-plus，然后进行Vue.use，就是这么厉害，直接在页面中用就完事了，并且按需加载组件和样式，非常的强大

## vite-plugin-pages

vite插件，可以读取文件夹下的vue文件，自动生成vue-router的路由信息，这样以后每次有新的vue页面增加，都不用去更改vue-router的路由信息代码了，减少了工作量

### 下载

```sh
yarn add -D vite-plugin-pages
yarn add vue-router@next
npm i -D vite-plugin-pages
npm i vue-router@next
```

### vite.config.ts配置

```ts
import Pages from "vite-plugin-pages"
export default defineConfig({
  plugins: [
    ...
      Pages({
      // 自动读取src/views下的vue文件，生成路由信息，默认路由路径'/‘
      dirs: [{ dir: "src/views", baseRoute: "/" }],
      // 异步方式加载路由组件
      importMode: "async",
      // 遍历路由信息，给默认路由加一个redirect
      extendRoute(route) {
       if (route.path === "/") return { ...route, redirect: "login" }
      }
    })
  ]
})
```

### main.ts使用vue-router

```typescript
import { createApp } from "vue"
import App from "./App.vue"

import { createRouter, createWebHashHistory } from "vue-router"
// 这里就是vite-plugin-pages生成的路由信息，正常使用即可
import routes from "virtual:generated-pages"

const router = createRouter({
  history: createWebHashHistory(),
  routes
})
createApp(App).use(router).mount("#app")
```

在env.d.ts中加入 /// \<reference types="vite-plugin-pages/client" />来提供typescript支持

```typescript
/// <reference types="vite/client" />
/// <reference types="vite-plugin-pages/client" />
declare module "*.vue" {
  import type { DefineComponent } from "vue"
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types
  const component: DefineComponent<{}, {}, any>
  export default component
}
```

现在可以在src/views下定义vue文件，会自动生成vue-router的路由信息
那么问题来了，遵循的规则是什么呢？很简单，像示例这样即可，我觉得还是很一目了然的，不用太多介绍

- src/views/index.vue -> /
- src/views/index/a.vue -> /a // 这里的a.vue就是index.vue的子路由（children）
- src/views/father.vue -> /father
- src/views/father/son.vue -> /father/son
- src/views/father/[id].vue -> /father/:id
- src/views/[father]/son.vue -> /:father/son

## vite-plugin-md

```sh
yarn add -D vite-plugin-md
```

自动注册 md 文件为 vue 组件

## prism-theme-vars

```sh
yarn add prism-theme-vars
```

prism 主题变量

新建 style.css,在 main.js 中导入

