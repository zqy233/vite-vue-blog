# 基础语法

## 数据类型

es6 之前五个基本类型一个引用类型，五个基本类型是`null`,`undefined`,`string`,`number`,`boolean`,一个引用类型是 `object`（包括 `object`，`function`，`array`），

es6 之后新增了 `symbol` 用来表示独一无二的数，和 `bigint`，所以总共是八种数据类型



## js-变量提升

什么是变量提升,举个栗子：

```js
function foo() {
  var a = 1
  function a() {}
  console.log(a) //1
}
foo()
```

```js
function foo() {
  var a
  function a() {}
  console.log(a) //a()
}
foo()
```

上方代码 js 是这样解析的

```js
function foo() {
  var a
  function a() {}
  a = 1
  console.log(a) //1
}
foo()
```

```js
function foo() {
  var a
  function a() {}
  console.log(a) //a()
}
foo()
```

变量提升的规则：
变量在声明提升的时候，是全部提升到作用域的最前面
变量赋值时赋值的位置在变量原本定义的位置
所以变量的提升，提升的其实是变量的声明，而不是变量的赋值

```js
function foo() {
  var a = 1
  console.log(a) // 1
  console.log(b) // undefined
  var b = 2
}
foo()
```

解析为：

```js
function foo() {
  var a
  var b
  a = 1
  console.log(a) // 1
  console.log(b) // undefined
  b = 2
}
foo()
```

函数提升则是整个函数整体提升

```js
function foo() {
  console.log(a) //a()
  var a = 1
  console.log(a) //1
  function a() {}
  console.log(a) //1
}
foo()
```

解析为：

```js
function foo() {
  var a
  function a() {}
  console.log(a) // a()
  a = 1
  console.log(a) // 1
  console.log(a) // 1
}
foo()
```

复杂一点的例子

```js
function foo() {
  var a
  var b
  function b() {}
  function a() {}
  console.log(a) // a()
  a = 1
  console.log(a) // 1
  console.log(b) // b()
  b = 2
  console.log(b) //2
}
```

解析为：

```js
function foo() {
  var a
  var b
  function b() {}
  function a() {}
  console.log(a) // a()
  a = 1
  console.log(a) // 1
  console.log(b) // b()
  b = 2
  console.log(b) //2
}
```

隐式全局变量不会提升

```js
function foo() {
  console.log(a)
  console.log(b) // 报错 b is not defined
  b = 'aaa'
  var a = 'bbb'
  console.log(a)
  console.log(b)
}
foo()
```

面试题

```js
console.log(a) //a()
a() //10
var a = 3
function a() {
  console.log(10)
}
console.log(a) //3
a = 6
a() // a is not a function
```

自己调用自己，需要一个结束条件来结束自我调用

原理：每次 return 都会结束函数的运行，但 return 时又调用了函数，从而继续运行下一次函数，又继续 return，又继续调用，直到满足结束条件，没有下一次调用

```js
function sum(n) {
  if (n == 1) return 1
  return sum(n - 1) + n
}
const amount = sum(5)
console.log(amount) //15
```

题目 1：传递两个参数 m，n，返回长度为 m，所有元素都为 n 的数组

```js
function fn(m, n) {
  return m ? fn(m - 1, n).concat(n) : []
}
console.log(fn(5, 4))
;[4, 4, 4, 4, 4]
```

## js-自调用

```js
const add = (function add() {})()
```

## js-闭包

JavaScript 变量可以是局部变量或全局变量（函数内部定义的变量是私有变量，函数外部定义的变量是全局变量）

获取或修改私有变量可以用到内嵌函数

闭包基于内嵌函数，return 一个内嵌函数，在内嵌函数中进行私有变量的处理

函数内部的私有变量可以通过内嵌函数修改

内嵌函数示例：

```
function add()
  {
    let counter = 0;
    function plus()
      {
        counter += 1;
    }
    plus();
    return counter;
}
console.log(add());   //1
```

闭包示例：

```
const add = (function add() {
  let counter = 0;
  return function(){
  return counter +=1}
  })()
  console.log(add()); //1
  console.log(add()); //2
```

## js-||

0 算 false

```js
const a = false || 1
console.log(a) // 1
const b = 0 || 1
console.log(b) // 1
```

```js
const a= 0
if(a){
    console.log(1)
}
```

```js
undefined | '' // 结果为0，interesting
```

## js-return

return 赋值语句的结果是 return 最左侧的变量

```js
let a = 1
const b = 2
function name() {
  return a = b
}
console.log(name())
```

return 有 true 则会 return true

```js
const a = false
const b = true
function name(params) {
  return a || b
}
console.log(name()) //true
```

```js
const a = false
const b = false
function name() {
  return a || b
}
console.log(name()) //false
```

## js-==和===区别

简单来说： == 代表相同， ===代表严格相同

当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比，如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是 false

操作数 1 == 操作数 2， 操作数 1 === 操作数 2

比较过程：

双等号==：

（1）如果两个值类型相同，再进行三个等号(===)的比较

 （2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：

1）如果一个是 null，一个是 undefined，那么相等

2）如果一个是 0，一个是 false，那么相等

3）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较

三等号===:

（1）如果类型不同，就一定不相等

（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是 NaN，那么不相等。（判断一个值是否是 NaN，只能使用 isNaN( ) 来判断）

（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。

（4）如果两个值都是 true，或是 false，那么相等

（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等

（6）如果两个值都是 null，或是 undefined，那么相等

```
const a = 0
console.log(a==false) // true
```

## js-window.onload

window 页面加载完成时调用

```js
window.onload = function () {}
```

## js-localStorage/sessionStorage 

使用 localStorage 创建一个本地存储的 name/value 键值对

localStorage 和 sessionStorage 属性允许在浏览器中存储 key/value 对的数据。

localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除

sessionStorage 只将数据保存在当前会话中，该数据对象临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据

localStorage 本质上是对字符串的读取，有 json 格式时需要 JSON.stringify()转化为字符串。

```js
localStorage.setItem('text', 'hello') //第一种存储方式
localStorage.text = 'world' //第二种存储方式
localStorage.getItem('text') //调用getItem方法取值
localStorage.text //直接取值
localStorage.removeItem('text') //删除localStorage
```

## js-事件冒泡/事件捕获

现有父子孙三层 dom 元素,依次包裹,大小相同,且三层 dom 都有点击事件

```html
<div class="father">
  <div class="son">
    <div class="grandson"></div>
  </div>
</div>
```

事件冒泡执行过程：点击 dom 元素,事件依次向上(向父一级)开始触发,触发顺序为孙>子>父

事件捕获执行过程：点击 dom 元素,事件依次向下(向子一级)开始触发,触发顺序为父>子>孙

## js-addEventListener 和 on 的区别

addEventListenert 第一个参数为事件名，第二个参数为函数，第三个参数为 Boolean,为 true 执行捕获机制,如果是 false 执行冒泡机制,可以省略,默认 false

```js
div.addEventListener('click', () => {
  console.log('click')
})
```

- on 同一个事件只能绑定单个方法,因为绑定多个,后一个会覆盖前一个

- addEventListener 可以给同一个事件绑定多个方法,且方法间不会覆盖,自上而下依次执行

- addEventListener 可以利用第三个参数决定采用事件冒泡还是事件捕获

- addEventListener 它对任何 DOM 元素都是有效的,而不仅仅只对 HTML 元素有效(DOM 不是专为 HTML 设计的，它是通用型的标准，为所有标记语言(如 java 中常见的 xml 等)而设计)

- addEventListener 为 DOM2 级事件绑定，onclick 为 DOM0 级事件绑定()

- 在移除事件上，on 是指针指向 null，例如 document.onclick = null，而 addEventListener 则使用的是独有的移除方法 removeListener（要使用此方法，addEventListener 必须执行的是外部函数或存在函数名，不然则不能使用）

- IE678 只能使用 attachEvent，无 addEventListener

## 鼠标事件

```js
toucshtart // 鼠标点击
touchmove // 鼠标离开
```

## js-dom 事件级别

1. 0 级只能定义一个事件，多事件会互相覆盖。
2. 1 级没有事件
3. 2 级多出了事件的自定义，并且还有事件冒泡和捕获。注意 ie11 以下的写法(IE 事件处理程序没有第三个参数，因为 IE 早期版本只支持事件冒泡，所以默认就是事件冒泡)
4. 3 级多了自定义事件，和一起其他扩展的事件

## js-原型与原型链

对象._proto_ === 其构造函数.prototype

每个对象都有叫做**proto**属性，这个属性会指向该对象的原型。

```js
function Person() {}
const person = new Person()
console.log(person.__proto__ === Person.prototype) // true
```

## js-dom 操作

获取dom

```js
document.querySelector // css选择器，获取单个dom
document.querySelectorAll // css选择器，获取全部dom
```

是否包含类名

```js
element.classList.contains('类名')
```

添加和移除类名

```js
element.classList.add('类名')
element.classList.remove('类名')
```

创建dom

```js
document.createElement('div')
```

## js-for循环

continue和break的区别：

###  continue

   终止本次循环，接着还执行下一次循环

### break

   用于完全结束一个循环，跳出循环体执行循环后面的语句

因为js中for是没有局部作用域的概念的，所以只有把for循环放在函数中时，才可以在for循环中使用return语句

## console.log

### 设置console.log颜色

调试js代码的时候，为调试的日志添加样式可以使信息更醒目

第一个参数就是要输出的字符串，通过`%c`分割的区间与之后的参数一一对应，参数就是标准的css，如果对应的参数不足，无法匹配`%c`会以字符串的形式输出，参数过多就会直接以字符串形式输出多余的样式。

```js
console.log("%cBinfoTeamFeUI", "font-size:20px;color:blue;background:yellow;", BinfoTeamFeUI)
```

## setTimeout

> > setTimeout(fn,millisec) 方法用于在指定的毫秒数后调用函数或计算表达式
> > 很简单，setTimeout() 只执行 fn 一次，到底什么时候执行取决于第二个参数millisec设定的毫秒数，所以很多人习惯上称之为延迟，无非就是延迟一段时间后再执行里面的代码

```js
setTimeout(function(){
 console.log('我是setTimeout')
}, 1000)
```

正常情况下，等1000毫秒以后会在浏览器的控制台输出

OK，看一个例子，这个例子的输出结果是什么？

```js
setTimeout(function(){
 console.log(1)
}, 0)
console.log(2)
console.log(3)
```

出乎一些人的意料，得到的结果竟然是`2、3、1`。这似乎不按套路出牌啊，明明是等待了0毫秒也就是不等待直接输出啊，为啥1却在最后输出了呢？

这就需要搞清楚一个很重要的概念：`js是单线程的`

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着

其实很好理解，就像大家去超市买东西一样，所有买东西的人都需要在收银台排队结账，正常情况下每个收银台同一时间只能为一位顾客结账，这位顾客结账完成才能为下一位顾客服务

而浏览器的内核是多线程的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：javascript引擎线程，GUI渲染线程，浏览器事件触发线程

javascript引擎是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序

GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意 GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行

事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。（当线程中没有执行任何同步代码的前提下才会执行异步代码）

其实，当js代码执行遇到setTimeout(fn,millisec)时，会把fn这个函数放在任务队列中，当js引擎线程空闲时并达到millisec指定的时间时，才会把fn放到js引擎线程中执行

HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout() 。

需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行

setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行
