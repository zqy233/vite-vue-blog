# 起步

## 示例

创建并进入一个目录文件夹

```sh
mkdir webpack-demo
cd webpack-demo
```

新建`src/index.js`，`index.html`

index.js

```js
function component() {
  const element = document.createElement('div');
  // 这里的_是lodash的语法
  element.innerHTML = _.join(['Hello', 'webpack'], ' ')
  return element
}
document.body.appendChild(component())
```

index.html

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>起步</title>
    <script src="https://unpkg.com/lodash@4.17.20"></script>
  </head>
  <body>
    <script src="./src/index.js"></script>
  </body>
</html>
```

在此示例中，`<script>` 标签之间存在`隐式依赖关系`(`index.js` 中的函数正常运行需要 `lodash`)

之所以称为`隐式依赖关系`，这是因为 `index.js` 并未`显式声明`它需要 `lodash`，而是直接就使用`lodash`的语法`_`

这样传统的`script src`的引用写法是会产生一些问题的：

- 无法直接体现`index.js`的执行依赖于`lodash`
- 如果 `lodash`不存在，或者引入顺序错误，`index.js`将无法正常运行
- 如果`lodash`被引入但是并没有使用，浏览器将被迫下载无用代码

也就是

- 无法直接体现`js`的执行`依赖于外部库`
- 如果`依赖的外部库`不存在，或者引入顺序错误，`js`将无法正常运行
- 如果`依赖的外部库`被引入但是并没有使用，浏览器将被迫下载无用代码

这就是为什么使用`webpack`来管理`js`

## 基本安装

初始化 package.json，在本地安装 `webpack`，安装 [`webpack-cli`](https://github.com/webpack/webpack-cli)（此工具用于在命令行中运行 webpack）

```sh
npm init -y
npm i webpack webpack-cli -D
```

## 创建一个 bundle

### 稍微调整下目录结构

创建`dist`文件夹用于存放`分发代码`，将`index.html`移动到`dist`文件夹中，`src`文件夹仍存放`源代码`

`分发代码`是指在构建过程中，经过最小化和优化后产生的输出结果，最终将在浏览器中加载。`源代码`是指用于书写和编辑的代码

### 安装lodash

```sh
npm install -s lodash
```

index.js

```js
import _ from "lodash"
function component() {
  const element = document.createElement("div")
  element.innerHTML = _.join(["Hello", "webpack"], " ")
  return element
}
document.body.appendChild(component())
```

