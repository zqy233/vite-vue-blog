# 实战

## 下载安装

```sh
yarn add qiankun 
```

## 主应用中注册微应用

```js
import { registerMicroApps, runAfterFirstMounted, setDefaultMountApp, start } from "qiankun"
import "./index.less"
/**
 * 主应用 **可以使用任意技术栈**
 * 以下分别是 React 和 Vue 的示例，可切换尝试
 */
import render from "./render/ReactRender"
// import render from './render/VueRender';

/**
 * Step1 初始化应用（可选）
 */
render({ loading: true })

const loader = loading => render({ loading })

/**
 * Step2 注册子应用
 */
registerMicroApps([
  {
    name: "react15", // 微应用的package.json的name
    entry: "//localhost:7102",
    container: "#subapp-viewport",
    loader,
    activeRule: "/react15"
  },
  {
    name: "vue", // 微应用的package.json的name
    entry: "//localhost:7106",
    container: "#subapp-viewport",
    loader,
    activeRule: "/vue"
  }
])

/** Step3 设置默认进入的子应用 */
setDefaultMountApp("/vue")

/** Step4 启动应用 */
start()

/** 第一次加载完成运行 */
runAfterFirstMounted(() => {
  console.log("[MainApp] first app mounted")
})
```

当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子

如果微应用不是直接跟路由关联的，也可以选择手动加载微应用的方式

```js
import { loadMicroApp } from 'qiankun';

loadMicroApp({
  name: 'app',
  entry: '//localhost:7100',
  container: '#yourContainer'
})
```

## 微应用

微应用不需要额外安装任何其他依赖即可接入 qiankun 主应用

### 1. 导出相应的生命周期钩子

微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 `bootstrap`、`mount`、`unmount` 三个生命周期钩子，以供主应用在适当的时机调用

```jsx
/**
 * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
 * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
 */
export async function bootstrap() {
  console.log('react app bootstraped');
}

/**
 * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
 */
export async function mount(props) {
  ReactDOM.render(<App />, props.container ? props.container.querySelector('#root') : document.getElementById('root'));
}

/**
 * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
 */
export async function unmount(props) {
  ReactDOM.unmountComponentAtNode(
    props.container ? props.container.querySelector('#root') : document.getElementById('root'),
  );
}

/**
 * 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效
 */
export async function update(props) {
  console.log('update props', props);
}
```

qiankun 基于 single-spa，所以你可以在[这里](https://single-spa.js.org/docs/building-applications.html#registered-application-lifecycle)找到更多关于微应用生命周期相关的文档说明。

无 webpack 等构建工具的应用接入方式请见[这里](https://qiankun.umijs.org/zh/guide/tutorial#非-webpack-构建的微应用)

## 微应用配置

### 打包配置

除了代码中暴露出相应的生命周期钩子之外，为了让主应用能正确识别微应用暴露出来的一些信息，微应用的打包工具需要增加如下配置：

`webpack.config.js`（vue脚手架的话则为`vue.config.js`）

```js
const packageName = require('./package.json').name;

module.exports = {
  ...
  output: {
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
    jsonpFunction: `webpackJsonp_${packageName}`,
  }
}
```

### 新增`public-path.js`

在 `src` 目录新增 `public-path.js`

```js
if (window.__POWERED_BY_QIANKUN__) {
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}
```

在入口文件顶层如main.js中导入`public-path.js`

```js
import "./public-path"
```

## vue-devtools无法调试子项目 

https://github.com/umijs/qiankun/issues/601

## 子应用打包配置

webpack4

```js
output: {
    // 把子应用打包成 umd 库格式
    library: `${name}-[name]`,
    libraryTarget: 'umd',
    jsonpFunction: `webpackJsonp_${name}`,
},
```

webpack5

```js
output: {
    // 把子应用打包成 umd 库格式
    library: `${name}-[name]`,
    libraryTarget: 'umd',
    chunkLoadingGlobal: `webpackJsonp_${name}`,
},
```

## 主应用和微应用都使用vue2

同级目录创建两个vue2项目，一个作为主应用，一个作为子应用

```sh
vue creat vuemain
vue creat vuesub
```

主应用下载qiankun

```sh
npm i -s qiankun
```

主应用的main.js

```js
import Vue from "vue"
import App from "./App.vue"
import router from "./router"
import store from "./store"
import { registerMicroApps, start, setDefaultMountApp } from "qiankun"

Vue.config.productionTip = false

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount("#app")

registerMicroApps([
  {
    name: "vuesub", // 微应用的名称，微应用之间必须确保唯一。
    entry: "//localhost:9002", // 必选，微应用的入口。
    container: "#subapp-container", // 必选，微应用的容器节点的选择器或者 Element 实例。
    activeRule: "/vuesub", // 必选，微应用的激活规则。
    props: {
      router // 将主应用的路由传给子应用，子应用才能返回到主应用上
    } // 参数
  }
])

//设置默认进入的子应用
setDefaultMountApp("/vuesub")

start()
```

主应用的路由，改为history模式

```js
import Vue from "vue"
import VueRouter from "vue-router"
import HomeView from "../views/HomeView.vue"

Vue.use(VueRouter)

const routes = [
  {
    path: "/",
    name: "home",
    component: HomeView
  },
  {
    path: "/about",
    name: "about",
    component: () => import("../views/AboutView.vue")
  }
]

const router = new VueRouter({
  routes,
  mode: "history"
})

export default router
```

主应用的App.vue

```vue
<template>
  <div id="app">
    <nav>
      <router-link to="/">Home</router-link> |
      <router-link to="/about">About</router-link>
    </nav>
    <router-view />
    <div id="subapp-container"></div>
  </div>
</template>
```

子应用新建public-path.js，然后在main.js顶部导入

```js
if (window.__POWERED_BY_QIANKUN__) {
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__
}
```

子应用的main.js

```js
import "./public-path"
import Vue from "vue"
import App from "./App.vue"
import router from "./router"
import store from "./store"

Vue.config.productionTip = false

let instance = null

function render(props = {}) {
  const { container } = props
  instance = new Vue({
    router,
    store,
    render: h => h(App)
  }).$mount(container ? container.querySelector("#app") : "#app")
}

if (!window.__POWERED_BY_QIANKUN__) {
  render()
}

//暴露三个qiankun的生命周期函数
export async function bootstrap() {
  console.log("%c ", "color: green;", "vue subapp bootstraped")
}

export async function unmount() {
  instance.$destroy()
  instance.$el.innerHTML = ""
  instance = null
}

export const mount = async props => {
  console.log("子应用加载")
  render(props)
}
```

子应用的路由

```js
import Vue from "vue"
import VueRouter from "vue-router"
import HomeView from "../views/HomeView.vue"

Vue.use(VueRouter)

const routes = [
  {
    path: "/vuesub",
    name: "home",
    component: HomeView
  },
  {
    path: "/vuesub/about",
    name: "about",
    component: () => import("../views/AboutView.vue")
  }
]

const router = new VueRouter({
  routes,
  mode: "history"
})

export default router
```

子应用的vue.config.js

```js
const { defineConfig } = require("@vue/cli-service")
const path = require("path")
const { packageName } = require("./package")
function resolve(dir) {
  return path.join(__dirname, dir)
}
module.exports = defineConfig({
  transpileDependencies: true,
  productionSourceMap: false,
  devServer: {
    hot: true,
    port: 9002, //与主应用配置的一致
    headers: {
      "Access-Control-Allow-Origin": "*"
    }
  },
  // 自定义webpack配置
  configureWebpack: {
    resolve: {
      alias: {
        "@": resolve("src")
      }
    },
    output: {
      // 把子应用打包成 umd 库格式
      library: "vuesub", //与主应用配置的一致
      libraryTarget: "umd",
      chunkLoadingGlobal: `webpackJsonp_${packageName}`
    }
  }
})
```

## 同一页面多个微应用

使用`loadMicroApp`手动加载微应用

```js
<template>
  <div id="app">
    <div id="subapp-container"></div>
    <div id="subapp-container1"></div>
  </div>
</template>

<script>
import { loadMicroApp } from "qiankun"

export default {
  mounted() {
    loadMicroApp({
      name: "vuesub", // 微应用的名称，微应用之间必须确保唯一
      entry: "//localhost:9002", // 必选，微应用的入口
      container: "#subapp-container" // 必选，微应用的容器节点的选择器或者 Element 实例
    })
    loadMicroApp({
      name: "secondsub", // 微应用的名称，微应用之间必须确保唯一
      entry: "//localhost:9001", // 必选，微应用的入口
      container: "#subapp-container1" // 必选，微应用的容器节点的选择器或者 Element 实例
    })
  }
}
</script>
```

## 多个微应用样式隔绝

默认情况下沙箱可以确保单实例场景子应用之间的样式隔离，但是无法确保主应用跟子应用、或者多实例场景的子应用样式隔离，当配置为 `{ strictStyleIsolation: true }` 时表示开启严格的样式隔离模式。这种模式下 qiankun 会为每个微应用的容器包裹上一个 [shadow dom](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM) 节点，从而确保微应用的样式不会对全局造成影响

当`{ experimentalStyleIsolation: true }` 时，qiankun 会改写子应用所添加的样式为所有样式规则增加一个特殊的选择器规则来限定其影响范围

默认直接使用 `{ strictStyleIsolation: true }`会报错，使用`{ experimentalStyleIsolation: true }`则正常使用，样式隔绝了

```js
 loadMicroApp(
      {
        name: "vuesub", // 微应用的名称，微应用之间必须确保唯一
        entry: "//localhost:9002", // 必选，微应用的入口
        container: "#subapp-container" // 必选，微应用的容器节点的选择器或者 Element 实例
      },
      {
        sandbox: {
          experimentalStyleIsolation: true
        }
      }
    )
    loadMicroApp(
      {
        name: "secondsub", // 微应用的名称，微应用之间必须确保唯一
        entry: "//localhost:9001", // 必选，微应用的入口
        container: "#subapp-container1" // 必选，微应用的容器节点的选择器或者 Element 实例
      },
      {
        sandbox: {
          experimentalStyleIsolation: true
        }
      }
    )
```

## 设置主应用启动后默认进入的微应用

```js
import { setDefaultMountApp } from 'qiankun'
setDefaultMountApp('/homeApp')
```

## 一键启动主应用和微应用

根目录安装` npm-run-all`这个npm包，可以并行运行多个命令

```sh
 npm i -D npm-run-all
 npm init -y
```

`package.json`添加`scripts`，--parallel:表示并行运行多个命令

```json
  "scripts": {
    "instasll-all": "npm-run-all --parallel install:*",
    "install:master": "cd projects/master & npm i",
    "install:vue-sub": "cd projects/vue-sub & npm i",
    "serve-all": "npm-run-all --parallel serve:*",
    "serve:master": "cd projects/master & npm run serve",
    "serve:vue-sub": "cd projects/vue-sub & npm run serve",
    "serve-:react-sub": "cd projects/react-sub & npm run serve",
    "build-all": "npm-run-all --parallel build:*",
    "build:master": "cd projects/master & npm run build",
    "build:vue-sub": "cd projects/vue-sub & npm run build"
  },
```

常用的参数

```sh
--parallel: 并行运行多个命令，例如：npm-run-all --parallel lint build
--serial: 多个命令按排列顺序执行，例如：npm-run-all --serial clean lint build:**
--continue-on-error: 是否忽略错误，添加此参数 npm-run-all 会自动退出出错的命令，继续运行正常的
--race: 添加此参数之后，只要有一个命令运行出错，那么 npm-run-all 就会结束掉全部的命令
```

## 主子应用间通信

### 主传子

```js
 loadMicroApp(
      {
        name: "vuesub", // 微应用的名称，微应用之间必须确保唯一
        entry: "//localhost:9002", // 必选，微应用的入口
        container: "#subapp-container", // 必选，微应用的容器节点的选择器或者 Element 实例
        props: {
          hello: "world"
        }
      },
      {
        sandbox: {
          experimentalStyleIsolation: true
        }
      }
    )
```

或者

子应用通过mount生命周期里的props接收

```js
export const mount = async props => {
  console.log("第一个vue子应用加载")
  props.onGlobalStateChange((state, prev) => {
    // state: 变更后的状态; prev 变更前的状态
    console.log("[微应用获取的全局值]", state, prev)
    // 第二个参数为true，表示立即触发
  }, true)
  // 打印props，发现多了一个hello属性，值为world
  console.log("[微应用props]", props)
  render(props)
}
```

### 子应用向主应用

子应用向主应用发送数据（子应用中修改数据，可以在主应用中监听到）

## 子应用render函数详解

`props.container`是子应用的根dom

所以`container ? container.querySelector("#app") : "#app")`的作用是如果子应用的根dom存在，那么基于根dom，用querySelector，这样就限制了查询dom的区间，避免子应用根dom相同的话出现冲突

```js
function render(props = {}) {
  const { container } = props
  instance = new Vue({
    router,
    store,
    render: h => h(App)
  }).$mount(container ? container.querySelector("#app") : "#app")
}

if (!window.__POWERED_BY_QIANKUN__) {
  render()
}
```

