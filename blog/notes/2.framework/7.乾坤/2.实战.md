# 实战

## 下载安装

```sh
yarn add qiankun 
```

## 主应用中注册微应用

```js
import { registerMicroApps, runAfterFirstMounted, setDefaultMountApp, start } from "qiankun"
import "./index.less"
/**
 * 主应用 **可以使用任意技术栈**
 * 以下分别是 React 和 Vue 的示例，可切换尝试
 */
import render from "./render/ReactRender"
// import render from './render/VueRender';

/**
 * Step1 初始化应用（可选）
 */
render({ loading: true })

const loader = loading => render({ loading })

/**
 * Step2 注册子应用
 */
registerMicroApps([
  {
    name: "react15", // 微应用的package.json的name
    entry: "//localhost:7102",
    container: "#subapp-viewport",
    loader,
    activeRule: "/react15"
  },
  {
    name: "vue", // 微应用的package.json的name
    entry: "//localhost:7106",
    container: "#subapp-viewport",
    loader,
    activeRule: "/vue"
  }
])

/** Step3 设置默认进入的子应用 */
setDefaultMountApp("/vue")

/** Step4 启动应用 */
start()

/** 第一次加载完成运行 */
runAfterFirstMounted(() => {
  console.log("[MainApp] first app mounted")
})
```

当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子

如果微应用不是直接跟路由关联的，也可以选择手动加载微应用的方式

```js
import { loadMicroApp } from 'qiankun';

loadMicroApp({
  name: 'app',
  entry: '//localhost:7100',
  container: '#yourContainer'
})
```

## 微应用

微应用不需要额外安装任何其他依赖即可接入 qiankun 主应用

### 1. 导出相应的生命周期钩子

微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 `bootstrap`、`mount`、`unmount` 三个生命周期钩子，以供主应用在适当的时机调用

```jsx
/**
 * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
 * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
 */
export async function bootstrap() {
  console.log('react app bootstraped');
}

/**
 * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
 */
export async function mount(props) {
  ReactDOM.render(<App />, props.container ? props.container.querySelector('#root') : document.getElementById('root'));
}

/**
 * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
 */
export async function unmount(props) {
  ReactDOM.unmountComponentAtNode(
    props.container ? props.container.querySelector('#root') : document.getElementById('root'),
  );
}

/**
 * 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效
 */
export async function update(props) {
  console.log('update props', props);
}
```

qiankun 基于 single-spa，所以你可以在[这里](https://single-spa.js.org/docs/building-applications.html#registered-application-lifecycle)找到更多关于微应用生命周期相关的文档说明。

无 webpack 等构建工具的应用接入方式请见[这里](https://qiankun.umijs.org/zh/guide/tutorial#非-webpack-构建的微应用)

## 微应用配置

### 打包配置

除了代码中暴露出相应的生命周期钩子之外，为了让主应用能正确识别微应用暴露出来的一些信息，微应用的打包工具需要增加如下配置：

`webpack.config.js`（vue脚手架的话则为`vue.config.js`）

```js
const packageName = require('./package.json').name;

module.exports = {
  ...
  output: {
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
    jsonpFunction: `webpackJsonp_${packageName}`,
  }
}
```

### 新增`public-path.js`

1. 在 `src` 目录新增 `public-path.js`：

   ```js
   if (window.__POWERED_BY_QIANKUN__) {
     __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
   }
   ```

## vue-devtools无法调试子项目 

https://github.com/umijs/qiankun/issues/601

## 子应用打包配置

webpack4

```js
output: {
    // 把子应用打包成 umd 库格式
    library: `${name}-[name]`,
    libraryTarget: 'umd',
    jsonpFunction: `webpackJsonp_${name}`,
},
```

webpack5

```js
output: {
    // 把子应用打包成 umd 库格式
    library: `${name}-[name]`,
    libraryTarget: 'umd',
    chunkLoadingGlobal: `webpackJsonp_${name}`,
},
```

## 主应用子应用package.json

- 调用一个npm包，子应用先从自身查找，找不到就使用上一级的npm包

## vue2主vue2子

同级目录创建两个vue2项目，一个作为主应用，一个作为子应用

```sh
vue creat vuemain
vue creat vuesub
```

主应用下载qiankun

```sh
npm i -s qiankun
```

主应用的main.js

```js
import Vue from "vue"
import App from "./App.vue"
import router from "./router"
import store from "./store"
import { registerMicroApps, start, setDefaultMountApp } from "qiankun"

Vue.config.productionTip = false

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount("#app")

registerMicroApps([
  {
    name: "vuesub", // 微应用的名称，微应用之间必须确保唯一。
    entry: "//localhost:9002", // 必选，微应用的入口。
    container: "#subapp-container", // 必选，微应用的容器节点的选择器或者 Element 实例。
    activeRule: "/vuesub", // 必选，微应用的激活规则。
    props: {
      router // 将主应用的路由传给子应用，子应用才能返回到主应用上
    } // 参数
  }
])

//设置默认进入的子应用
setDefaultMountApp("/vuesub")

start()
```

主应用的路由，改为history模式

```js
import Vue from "vue"
import VueRouter from "vue-router"
import HomeView from "../views/HomeView.vue"

Vue.use(VueRouter)

const routes = [
  {
    path: "/",
    name: "home",
    component: HomeView
  },
  {
    path: "/about",
    name: "about",
    component: () => import("../views/AboutView.vue")
  }
]

const router = new VueRouter({
  routes,
  mode: "history"
})

export default router
```

主应用的App.vue

```vue
<template>
  <div id="app">
    <nav>
      <router-link to="/">Home</router-link> |
      <router-link to="/about">About</router-link>
    </nav>
    <router-view />
    <div id="subapp-container"></div>
  </div>
</template>
```

子应用新建public-path.js，然后在main.js顶部导入

```js
if (window.__POWERED_BY_QIANKUN__) {
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__
}
```

子应用的main.js

```js
import "./public-path"
import Vue from "vue"
import App from "./App.vue"
import router from "./router"
import store from "./store"

Vue.config.productionTip = false

let instance = null

function render(props = {}) {
  const { container } = props
  instance = new Vue({
    router,
    store,
    render: h => h(App)
  }).$mount(container ? container.querySelector("#app") : "#app")
}

if (!window.__POWERED_BY_QIANKUN__) {
  render()
}

//暴露三个qiankun的生命周期函数
export async function bootstrap() {
  console.log("%c ", "color: green;", "vue subapp bootstraped")
}

export async function unmount() {
  instance.$destroy()
  instance.$el.innerHTML = ""
  instance = null
}

export const mount = async props => {
  console.log("子应用加载")
  render(props)
}
```

子应用的路由

```js
import Vue from "vue"
import VueRouter from "vue-router"
import HomeView from "../views/HomeView.vue"

Vue.use(VueRouter)

const routes = [
  {
    path: "/vuesub",
    name: "home",
    component: HomeView
  },
  {
    path: "/vuesub/about",
    name: "about",
    component: () => import("../views/AboutView.vue")
  }
]

const router = new VueRouter({
  routes,
  mode: "history"
})

export default router
```

子应用的vue.config.js

```js
const { defineConfig } = require("@vue/cli-service")
const path = require("path")
const { packageName } = require("./package")
function resolve(dir) {
  return path.join(__dirname, dir)
}
module.exports = defineConfig({
  transpileDependencies: true,
  productionSourceMap: false,
  devServer: {
    hot: true,
    port: 9002, //与主应用配置的一致
    headers: {
      "Access-Control-Allow-Origin": "*"
    }
  },
  // 自定义webpack配置
  configureWebpack: {
    resolve: {
      alias: {
        "@": resolve("src")
      }
    },
    output: {
      // 把子应用打包成 umd 库格式
      library: "vuesub", //与主应用配置的一致
      libraryTarget: "umd",
      chunkLoadingGlobal: `webpackJsonp_${packageName}`
    }
  }
})
```

## 同一页面多个微应用

```js
<template>
  <div id="app">
    <div id="subapp-container"></div>
    <div id="subapp-container1"></div>
  </div>
</template>

<script>
import { loadMicroApp } from "qiankun"

export default {
  mounted() {
    loadMicroApp({
      name: "vuesub", // 微应用的名称，微应用之间必须确保唯一
      entry: "//localhost:9002", // 必选，微应用的入口
      container: "#subapp-container" // 必选，微应用的容器节点的选择器或者 Element 实例
    })
    loadMicroApp({
      name: "secondsub", // 微应用的名称，微应用之间必须确保唯一
      entry: "//localhost:9001", // 必选，微应用的入口
      container: "#subapp-container1" // 必选，微应用的容器节点的选择器或者 Element 实例
    })
  }
}
</script>
```

